"""
Data Fetcher Module v0.1

負責從交易所下載歷史 OHLCV 數據。
使用 ccxt 庫與 Binance 交易所互動。
"""

import ccxt
import pandas as pd
from datetime import datetime
from typing import Optional
import time
import logging
from pathlib import Path

# 設定日誌
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class OHLCVFetcher:
    """OHLCV 數據下載器"""

    def __init__(self, exchange_name: str = "binance"):
        """
        初始化 OHLCV Fetcher

        Args:
            exchange_name: 交易所名稱，預設為 binance
        """
        self.exchange_name = exchange_name
        self.exchange = self._init_exchange()

    def _init_exchange(self) -> ccxt.Exchange:
        """
        初始化交易所實例

        Returns:
            ccxt.Exchange 實例
        """
        try:
            exchange_class = getattr(ccxt, self.exchange_name)
            exchange = exchange_class({
                'enableRateLimit': True,  # 啟用速率限制
                'options': {
                    'defaultType': 'spot',  # 使用現貨市場
                }
            })
            logger.info(f"成功初始化交易所: {self.exchange_name}")
            return exchange
        except Exception as e:
            logger.error(f"初始化交易所失敗: {e}")
            raise

    def fetch_ohlcv(
        self,
        symbol: str,
        timeframe: str,
        start_date: str,
        end_date: str,
        save_path: str,
        max_retries: int = 3
    ) -> str:
        """
        下載 OHLCV 數據並儲存為 CSV

        Args:
            symbol: 交易對符號，例如 'BTC/USDT'
            timeframe: 時間週期，例如 '1h'
            start_date: 起始日期，格式 'YYYY-MM-DD'
            end_date: 結束日期，格式 'YYYY-MM-DD'
            save_path: CSV 儲存路徑
            max_retries: API 錯誤時的最大重試次數

        Returns:
            str: CSV 檔案路徑

        Raises:
            Exception: 當達到最大重試次數仍失敗時
        """
        logger.info(f"開始下載 {symbol} {timeframe} 數據")
        logger.info(f"期間: {start_date} 至 {end_date}")

        # 轉換日期為毫秒時間戳
        start_ts = self._date_to_milliseconds(start_date)
        end_ts = self._date_to_milliseconds(end_date)

        # 計算每次請求的時間範圍（避免單次請求過大）
        # ccxt 通常限制單次請求最多 1000 根 K 線
        timeframe_ms = self._timeframe_to_milliseconds(timeframe)
        limit = 1000  # 每次請求的 K 線數量

        all_ohlcv = []
        current_ts = start_ts

        while current_ts < end_ts:
            retry_count = 0
            success = False

            while retry_count < max_retries and not success:
                try:
                    # 下載數據
                    ohlcv = self.exchange.fetch_ohlcv(
                        symbol=symbol,
                        timeframe=timeframe,
                        since=current_ts,
                        limit=limit
                    )

                    if not ohlcv:
                        logger.warning(f"沒有取得數據，時間戳: {current_ts}")
                        break

                    # 過濾超出結束時間的數據
                    filtered_ohlcv = [
                        candle for candle in ohlcv
                        if candle[0] < end_ts
                    ]

                    if filtered_ohlcv:
                        all_ohlcv.extend(filtered_ohlcv)
                        last_ts = filtered_ohlcv[-1][0]
                        logger.info(
                            f"已下載 {len(filtered_ohlcv)} 根 K 線，"
                            f"累計: {len(all_ohlcv)} 根，"
                            f"最後時間: {self._milliseconds_to_date(last_ts)}"
                        )
                        current_ts = last_ts + timeframe_ms
                    else:
                        break

                    success = True

                    # 避免請求過快
                    time.sleep(self.exchange.rateLimit / 1000)

                except Exception as e:
                    retry_count += 1
                    logger.warning(
                        f"API 請求失敗 (重試 {retry_count}/{max_retries}): {e}"
                    )
                    if retry_count < max_retries:
                        time.sleep(2 ** retry_count)  # 指數退避
                    else:
                        logger.error(f"達到最大重試次數，放棄請求")
                        raise Exception(f"API 請求失敗: {e}")

            if not success:
                break

        if not all_ohlcv:
            raise Exception("未能下載任何數據")

        # 轉換為 DataFrame
        df = pd.DataFrame(
            all_ohlcv,
            columns=['timestamp', 'open', 'high', 'low', 'close', 'volume']
        )

        # 移除重複的時間戳（如果有）
        df = df.drop_duplicates(subset=['timestamp'], keep='first')

        # 排序
        df = df.sort_values('timestamp').reset_index(drop=True)

        # 確保目錄存在
        Path(save_path).parent.mkdir(parents=True, exist_ok=True)

        # 儲存為 CSV
        df.to_csv(save_path, index=False)
        logger.info(f"數據已儲存至: {save_path}")
        logger.info(f"總共 {len(df)} 根 K 線")

        return save_path

    def _date_to_milliseconds(self, date_str: str) -> int:
        """
        將日期字串轉換為毫秒時間戳

        Args:
            date_str: 日期字串，格式 'YYYY-MM-DD'

        Returns:
            int: 毫秒時間戳
        """
        dt = datetime.strptime(date_str, '%Y-%m-%d')
        return int(dt.timestamp() * 1000)

    def _milliseconds_to_date(self, ms: int) -> str:
        """
        將毫秒時間戳轉換為日期字串

        Args:
            ms: 毫秒時間戳

        Returns:
            str: 日期字串，格式 'YYYY-MM-DD HH:MM:SS'
        """
        dt = datetime.fromtimestamp(ms / 1000)
        return dt.strftime('%Y-%m-%d %H:%M:%S')

    def _timeframe_to_milliseconds(self, timeframe: str) -> int:
        """
        將時間週期轉換為毫秒

        Args:
            timeframe: 時間週期，例如 '1h', '1d'

        Returns:
            int: 毫秒數
        """
        unit = timeframe[-1]
        amount = int(timeframe[:-1])

        unit_ms = {
            'm': 60 * 1000,           # 分鐘
            'h': 60 * 60 * 1000,      # 小時
            'd': 24 * 60 * 60 * 1000, # 天
            'w': 7 * 24 * 60 * 60 * 1000, # 週
        }

        if unit not in unit_ms:
            raise ValueError(f"不支援的時間週期單位: {unit}")

        return amount * unit_ms[unit]


def download_btcusdt_1h(
    start_date: str = "2020-01-01",
    end_date: str = "2024-01-01",
    save_path: str = "data/raw/BTCUSDT_1h.csv"
) -> str:
    """
    便捷函數：下載 BTCUSDT 1h 數據

    Args:
        start_date: 起始日期
        end_date: 結束日期
        save_path: 儲存路徑

    Returns:
        str: CSV 檔案路徑
    """
    fetcher = OHLCVFetcher(exchange_name="binance")
    return fetcher.fetch_ohlcv(
        symbol="BTC/USDT",
        timeframe="1h",
        start_date=start_date,
        end_date=end_date,
        save_path=save_path
    )


if __name__ == "__main__":
    # 測試下載
    print("開始下載 BTC/USDT 1h 數據...")
    print("這將需要一些時間，請耐心等候...")

    try:
        csv_path = download_btcusdt_1h()
        print(f"\n✓ 下載完成: {csv_path}")
    except Exception as e:
        print(f"\n✗ 下載失敗: {e}")
        import sys
        sys.exit(1)
