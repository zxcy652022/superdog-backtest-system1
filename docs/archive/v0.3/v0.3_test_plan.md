# Backtest Engine v0.3 - Comprehensive Test Plan

**版本**: v0.3
**状态**: 设计完成
**日期**: 2025-12-04
**目标**: 定义v0.3的完整测试策略和测试案例

---

## 1. 测试策略概述

### 1.1 测试金字塔

```
           ╱━━━━━━━━╲
          ╱  E2E (5) ╲          集成测试、CLI测试
         ╱━━━━━━━━━━━━╲
        ╱              ╲
       ╱ Integration   ╲        模块间协作测试
      ╱     (15)        ╲
     ╱━━━━━━━━━━━━━━━━━━╲
    ╱                    ╲
   ╱   Unit Tests (40)    ╲     单元测试
  ╱________________________╲
```

**总测试案例数**: 60+

### 1.2 测试范围

| 模块 | 单元测试 | 集成测试 | E2E测试 | 总计 |
|------|----------|----------|---------|------|
| Broker (做空/槓桿) | 15 | 3 | - | 18 |
| Engine (SL/TP方向感知) | 8 | 2 | - | 10 |
| Portfolio Runner | 12 | 5 | - | 17 |
| Text Reporter | 8 | 2 | - | 10 |
| CLI | - | - | 5 | 5 |
| **总计** | **43** | **12** | **5** | **60** |

### 1.3 测试工具

- **单元测试**: pytest
- **覆盖率**: pytest-cov
- **Mock**: unittest.mock
- **CLI测试**: Click.testing.CliRunner
- **数据夹具**: tests/fixtures/

---

## 2. Broker模块测试（做空/槓桿）

### 2.1 核心功能测试（15个）

#### A. 开多单

```python
def test_open_long_basic():
    """测试开多单基本功能"""
    broker = SimulatedBroker(initial_cash=10000)
    success = broker.buy(size=100, price=100, time=pd.Timestamp('2024-01-01'))

    assert success == True
    assert broker.position_qty == 100
    assert broker.position_direction == "long"
    assert broker.is_long == True


def test_open_long_with_leverage():
    """测试使用槓桿开多单"""
    broker = SimulatedBroker(initial_cash=10000, leverage=5.0)
    success = broker.buy(size=500, price=100, time=pd.Timestamp('2024-01-01'))

    assert success == True
    assert broker.position_qty == 500
    # 验证占用资金 = 50000 / 5 = 10000（全部占用）


def test_open_long_insufficient_cash():
    """测试资金不足时无法开仓"""
    broker = SimulatedBroker(initial_cash=1000)
    success = broker.buy(size=100, price=100, time=pd.Timestamp('2024-01-01'))

    assert success == False
    assert broker.has_position == False
```

#### B. 开空单

```python
def test_open_short_basic():
    """测试开空单基本功能"""
    broker = SimulatedBroker(initial_cash=10000)
    success = broker.sell(size=100, price=100, time=pd.Timestamp('2024-01-01'))

    assert success == True
    assert broker.position_qty == 100
    assert broker.position_direction == "short"
    assert broker.is_short == True


def test_open_short_with_leverage():
    """测试使用槓桿开空单"""
    broker = SimulatedBroker(initial_cash=10000, leverage=3.0)
    success = broker.sell(size=300, price=100, time=pd.Timestamp('2024-01-01'))

    assert success == True
    assert broker.position_qty == 300
```

#### C. 平多单

```python
def test_close_long_profit():
    """测试平多单（盈利）"""
    broker = SimulatedBroker(initial_cash=10000)
    broker.buy(size=100, price=100, time=pd.Timestamp('2024-01-01'))
    broker.sell(size=100, price=110, time=pd.Timestamp('2024-01-02'))

    assert broker.has_position == False
    assert len(broker.trades) == 1
    assert broker.trades[0].direction == "long"
    assert broker.trades[0].pnl > 0  # 盈利


def test_close_long_loss():
    """测试平多单（亏损）"""
    broker = SimulatedBroker(initial_cash=10000)
    broker.buy(size=100, price=100, time=pd.Timestamp('2024-01-01'))
    broker.sell(size=100, price=90, time=pd.Timestamp('2024-01-02'))

    assert broker.trades[0].pnl < 0  # 亏损
```

#### D. 平空单

```python
def test_close_short_profit():
    """测试平空单（盈利）"""
    broker = SimulatedBroker(initial_cash=10000)
    broker.sell(size=100, price=100, time=pd.Timestamp('2024-01-01'))  # 开空
    broker.buy(size=100, price=90, time=pd.Timestamp('2024-01-02'))    # 平空（价格下跌，盈利）

    assert broker.has_position == False
    assert len(broker.trades) == 1
    assert broker.trades[0].direction == "short"
    assert broker.trades[0].pnl > 0  # 盈利


def test_close_short_loss():
    """测试平空单（亏损）"""
    broker = SimulatedBroker(initial_cash=10000)
    broker.sell(size=100, price=100, time=pd.Timestamp('2024-01-01'))  # 开空
    broker.buy(size=100, price=110, time=pd.Timestamp('2024-01-02'))   # 平空（价格上涨，亏损）

    assert broker.trades[0].pnl < 0  # 亏损
```

#### E. 边界情况

```python
def test_buy_with_zero_size():
    """测试size=0时不执行"""
    broker = SimulatedBroker(initial_cash=10000)
    success = broker.buy(size=0, price=100, time=pd.Timestamp('2024-01-01'))

    assert success == False
    assert broker.has_position == False


def test_cannot_add_to_long():
    """测试持有多单时不能继续买入（不支持加仓）"""
    broker = SimulatedBroker(initial_cash=10000)
    broker.buy(size=50, price=100, time=pd.Timestamp('2024-01-01'))
    success = broker.buy(size=50, price=100, time=pd.Timestamp('2024-01-02'))

    assert success == False
    assert broker.position_qty == 50  # 仍然是原来的仓位


def test_cannot_add_to_short():
    """测试持有空单时不能继续卖出（不支持加仓）"""
    broker = SimulatedBroker(initial_cash=10000)
    broker.sell(size=50, price=100, time=pd.Timestamp('2024-01-01'))
    success = broker.sell(size=50, price=100, time=pd.Timestamp('2024-01-02'))

    assert success == False
    assert broker.position_qty == 50


def test_allow_negative_equity():
    """测试允许equity为负（v0.3不检查爆仓）"""
    broker = SimulatedBroker(initial_cash=1000, leverage=10.0)
    broker.buy(size=100, price=100, time=pd.Timestamp('2024-01-01'))  # 占用1000
    broker.sell(size=100, price=50, time=pd.Timestamp('2024-01-02'))  # 巨亏

    # equity会变成负数，但允许
    assert broker.cash < 0  # 允许负数


def test_leverage_bounds():
    """测试槓桿倍数边界"""
    # 槓桿 < 1 应抛出错误
    with pytest.raises(ValueError):
        SimulatedBroker(initial_cash=10000, leverage=0.5)

    # 槓桿 > 100 应抛出错误
    with pytest.raises(ValueError):
        SimulatedBroker(initial_cash=10000, leverage=101)
```

### 2.2 Trade对象测试（3个）

```python
def test_trade_has_direction():
    """测试Trade对象包含direction字段"""
    broker = SimulatedBroker(initial_cash=10000)
    broker.buy(size=100, price=100, time=pd.Timestamp('2024-01-01'))
    broker.sell(size=100, price=110, time=pd.Timestamp('2024-01-02'))

    trade = broker.trades[0]
    assert hasattr(trade, 'direction')
    assert trade.direction == "long"


def test_trade_has_leverage():
    """测试Trade对象包含leverage字段"""
    broker = SimulatedBroker(initial_cash=10000, leverage=3.0)
    broker.buy(size=300, price=100, time=pd.Timestamp('2024-01-01'))
    broker.sell(size=300, price=110, time=pd.Timestamp('2024-01-02'))

    trade = broker.trades[0]
    assert hasattr(trade, 'leverage')
    assert trade.leverage == 3.0


def test_trade_pnl_calculation_short():
    """测试空单PnL计算正确"""
    broker = SimulatedBroker(initial_cash=10000)
    broker.sell(size=100, price=100, time=pd.Timestamp('2024-01-01'))
    broker.buy(size=100, price=90, time=pd.Timestamp('2024-01-02'))

    trade = broker.trades[0]
    # 做空: 卖100@100, 买100@90 → PnL = 100 * (100-90) - fees
    expected_pnl_approx = 1000  # 约1000（扣除手续费会少一些）
    assert trade.pnl > 900  # 大于900即可（考虑手续费）
```

---

## 3. Engine模块测试（SL/TP方向感知）

### 3.1 核心功能测试（8个）

```python
def test_long_stop_loss():
    """测试多单止损触发"""
    # 准备数据：价格下跌触发SL
    data = create_test_data_with_drop()

    result = run_backtest(
        data=data,
        strategy_cls=SimpleBuyHoldStrategy,  # 买入并持有
        stop_loss_pct=0.02  # 2%止损
    )

    # 验证至少有一笔交易是SL退出
    assert result.trade_log is not None
    sl_trades = result.trade_log[result.trade_log['exit_reason'] == 'stop_loss']
    assert len(sl_trades) > 0


def test_long_take_profit():
    """测试多单止盈触发"""
    data = create_test_data_with_rise()

    result = run_backtest(
        data=data,
        strategy_cls=SimpleBuyHoldStrategy,
        take_profit_pct=0.05  # 5%止盈
    )

    tp_trades = result.trade_log[result.trade_log['exit_reason'] == 'take_profit']
    assert len(tp_trades) > 0


def test_short_stop_loss():
    """测试空单止损触发（价格上涨触发）"""
    data = create_test_data_with_rise()

    result = run_backtest(
        data=data,
        strategy_cls=SimpleShortStrategy,  # 做空策略
        stop_loss_pct=0.02  # 价格上涨2%触发
    )

    sl_trades = result.trade_log[result.trade_log['exit_reason'] == 'stop_loss']
    assert len(sl_trades) > 0


def test_short_take_profit():
    """测试空单止盈触发（价格下跌触发）"""
    data = create_test_data_with_drop()

    result = run_backtest(
        data=data,
        strategy_cls=SimpleShortStrategy,
        take_profit_pct=0.05  # 价格下跌5%触发
    )

    tp_trades = result.trade_log[result.trade_log['exit_reason'] == 'take_profit']
    assert len(tp_trades) > 0


def test_sl_priority_over_tp_long():
    """测试多单SL优先于TP"""
    # 创建同时触发SL和TP的K线（宽幅震荡）
    data = create_test_data_wide_range()

    result = run_backtest(
        data=data,
        strategy_cls=SimpleBuyHoldStrategy,
        stop_loss_pct=0.03,
        take_profit_pct=0.03
    )

    # 如果同时触发，应该是SL
    # （需要仔细构造数据来验证这一点）


def test_sl_priority_over_tp_short():
    """测试空单SL优先于TP"""
    # 类似上面，但用空单


def test_direction_aware_sl_tp():
    """测试_check_sl_tp函数的方向感知"""
    from backtest.engine import _check_sl_tp

    # 多单
    row = pd.Series({'low': 95, 'high': 105, 'close': 100})
    sl, tp, price, reason = _check_sl_tp(
        row=row,
        entry_price=100,
        direction="long",
        stop_loss_pct=0.02,  # SL = 98
        take_profit_pct=0.05  # TP = 105
    )

    # low=95触发SL
    assert sl == True
    assert reason == "stop_loss"

    # 空单（反过来）
    sl, tp, price, reason = _check_sl_tp(
        row=row,
        entry_price=100,
        direction="short",
        stop_loss_pct=0.02,  # SL = 102
        take_profit_pct=0.05  # TP = 95
    )

    # high=105触发SL（空单止损是价格上涨）
    assert sl == True
    assert reason == "stop_loss"


def test_leverage_in_backtest():
    """测试回测中使用槓桿"""
    data = load_ohlcv("data/raw/BTCUSDT_1h_test.csv")

    # 1倍槓桿
    result_1x = run_backtest(
        data=data,
        strategy_cls=SimpleSMAStrategy,
        initial_cash=10000,
        leverage=1.0
    )

    # 3倍槓桿
    result_3x = run_backtest(
        data=data,
        strategy_cls=SimpleSMAStrategy,
        initial_cash=10000,
        leverage=3.0
    )

    # 3倍槓桿的收益率应该约等于1倍的3倍（忽略手续费差异）
    # （这个测试需要精心设计数据才能准确验证）
```

---

## 4. Portfolio Runner测试

### 4.1 单元测试（12个）

```python
def test_run_config_validation():
    """测试RunConfig的参数验证"""
    # strategy为空应报错
    with pytest.raises(ValueError):
        RunConfig(strategy="", symbol="BTCUSDT", timeframe="1h")

    # leverage超出范围应报错
    with pytest.raises(ValueError):
        RunConfig(strategy="sma", symbol="BTCUSDT", timeframe="1h", leverage=200)


def test_run_config_to_dict():
    """测试RunConfig转字典"""
    config = RunConfig(strategy="sma", symbol="BTCUSDT", timeframe="1h")
    d = config.to_dict()

    assert d['strategy'] == "sma"
    assert d['symbol'] == "BTCUSDT"


def test_single_run_result_get_metrics():
    """测试SingleRunResult获取metrics"""
    # 成功的结果
    result = SingleRunResult(
        strategy="sma",
        symbol="BTCUSDT",
        timeframe="1h",
        config=mock_config,
        success=True,
        backtest_result=mock_backtest_result,
        error=None
    )

    metrics = result.get_metrics()
    assert 'total_return' in metrics

    # 失败的结果
    failed_result = SingleRunResult(
        strategy="sma",
        symbol="BTCUSDT",
        timeframe="1h",
        config=mock_config,
        success=False,
        backtest_result=None,
        error="Data not found"
    )

    assert failed_result.get_metrics() == {}


def test_portfolio_result_get_successful_runs():
    """测试获取成功的回测"""
    result = PortfolioResult(runs=[
        mock_success_run,
        mock_failed_run,
        mock_success_run
    ])

    successful = result.get_successful_runs()
    assert len(successful) == 2


def test_portfolio_result_get_failed_runs():
    """测试获取失败的回测"""
    result = PortfolioResult(runs=[
        mock_success_run,
        mock_failed_run
    ])

    failed = result.get_failed_runs()
    assert len(failed) == 1
    assert failed[0].error is not None


def test_portfolio_result_get_best_by():
    """测试按metric排序"""
    runs = [
        create_run_with_return(0.1),  # 10%
        create_run_with_return(0.3),  # 30%
        create_run_with_return(0.2),  # 20%
    ]

    result = PortfolioResult(runs=runs)
    best = result.get_best_by("total_return", top_n=1)

    assert len(best) == 1
    assert best[0].get_metric("total_return") == 0.3


def test_portfolio_result_to_dataframe():
    """测试转换为DataFrame"""
    result = PortfolioResult(runs=[
        mock_success_run,
        mock_failed_run
    ])

    df = result.to_dataframe(include_failed=True)

    assert isinstance(df, pd.DataFrame)
    assert 'strategy' in df.columns
    assert 'total_return' in df.columns
    assert len(df) == 2


def test_portfolio_result_filter():
    """测试自定义过滤"""
    result = PortfolioResult(runs=[
        create_run("sma", "BTCUSDT"),
        create_run("sma", "ETHUSDT"),
        create_run("trend", "BTCUSDT")
    ])

    btc_runs = result.filter(lambda r: r.symbol == "BTCUSDT")
    assert len(btc_runs) == 2


def test_run_single_backtest_success():
    """测试执行单次回测成功"""
    config = RunConfig(
        strategy="simple_sma",
        symbol="BTCUSDT",
        timeframe="1h"
    )

    from execution_engine.portfolio_runner import _run_single_backtest

    result = _run_single_backtest(config, verbose=False)

    assert result.success == True
    assert result.backtest_result is not None
    assert result.error is None


def test_run_single_backtest_strategy_not_found():
    """测试策略不存在"""
    config = RunConfig(
        strategy="invalid_strategy",
        symbol="BTCUSDT",
        timeframe="1h"
    )

    result = _run_single_backtest(config, verbose=False)

    assert result.success == False
    assert "Strategy not found" in result.error


def test_run_single_backtest_data_not_found():
    """测试数据文件不存在"""
    config = RunConfig(
        strategy="simple_sma",
        symbol="INVALID",
        timeframe="1h"
    )

    result = _run_single_backtest(config, verbose=False)

    assert result.success == False
    assert "Data file not found" in result.error or "not found" in result.error.lower()


def test_load_configs_from_yaml():
    """测试从YAML加载配置"""
    from execution_engine.portfolio_runner import load_configs_from_yaml

    configs = load_configs_from_yaml("tests/fixtures/test_config.yml")

    assert isinstance(configs, list)
    assert len(configs) > 0
    assert all(isinstance(c, RunConfig) for c in configs)
```

### 4.2 集成测试（5个）

```python
def test_run_portfolio_multiple_strategies():
    """测试批量执行多个策略"""
    configs = [
        RunConfig(strategy="simple_sma", symbol="BTCUSDT", timeframe="1h"),
        RunConfig(strategy="trend_follow", symbol="BTCUSDT", timeframe="1h")
    ]

    result = run_portfolio(configs, verbose=False)

    assert len(result.runs) == 2
    assert result.count_successful() >= 0  # 可能成功也可能失败


def test_run_portfolio_with_failures():
    """测试包含失败的批量回测"""
    configs = [
        RunConfig(strategy="simple_sma", symbol="BTCUSDT", timeframe="1h"),
        RunConfig(strategy="invalid", symbol="BTCUSDT", timeframe="1h"),  # 会失败
    ]

    result = run_portfolio(configs, verbose=False, fail_fast=False)

    assert len(result.runs) == 2
    assert result.count_failed() >= 1


def test_run_portfolio_fail_fast():
    """测试fail_fast模式"""
    configs = [
        RunConfig(strategy="invalid", symbol="BTCUSDT", timeframe="1h"),  # 会失败
        RunConfig(strategy="simple_sma", symbol="BTCUSDT", timeframe="1h"),
    ]

    result = run_portfolio(configs, verbose=False, fail_fast=True)

    # 第一个失败后应该停止
    assert len(result.runs) == 1
    assert result.runs[0].success == False


def test_run_portfolio_date_filtering():
    """测试日期过滤"""
    config = RunConfig(
        strategy="simple_sma",
        symbol="BTCUSDT",
        timeframe="1h",
        start="2024-01-01",
        end="2024-01-31"
    )

    result = run_portfolio([config], verbose=False)

    # 验证日期范围（通过equity_curve的index）
    if result.count_successful() > 0:
        equity_curve = result[0].backtest_result.equity_curve
        assert equity_curve.index[0] >= pd.Timestamp("2024-01-01")
        assert equity_curve.index[-1] <= pd.Timestamp("2024-01-31")


def test_run_portfolio_position_sizer():
    """测试使用Position Sizer配置"""
    config = RunConfig(
        strategy="simple_sma",
        symbol="BTCUSDT",
        timeframe="1h",
        position_sizer={
            "type": "PercentOfEquitySizer",
            "percent": 0.5
        }
    )

    result = run_portfolio([config], verbose=False)

    # 确保不报错
    assert len(result.runs) == 1
```

---

## 5. Text Reporter测试

### 5.1 单元测试（8个）

```python
def test_render_single_basic():
    """测试render_single基本输出"""
    from reports.text_reporter import render_single

    report = render_single(mock_backtest_result, config=mock_config)

    assert "BACKTEST REPORT" in report
    assert "PERFORMANCE SUMMARY" in report
    assert "TRADE STATISTICS" in report


def test_render_single_with_trades():
    """测试包含交易记录的报表"""
    report = render_single(result_with_trades)

    assert "RECENT TRADES" in report


def test_render_single_zero_trades():
    """测试无交易的报表"""
    report = render_single(result_zero_trades)

    assert "0" in report or "No trades" in report.lower()


def test_render_portfolio_basic():
    """测试render_portfolio基本输出"""
    from reports.text_reporter import render_portfolio

    report = render_portfolio(mock_portfolio_result)

    assert "PORTFOLIO" in report
    assert "RANKING TABLE" in report


def test_render_portfolio_sorting():
    """测试排序功能"""
    report = render_portfolio(mock_portfolio_result, sort_by="profit_factor")

    # 验证排序（第一行应该是PF最高的）
    # （需要解析report文本来验证，或mock数据确保顺序）


def test_render_portfolio_show_failed():
    """测试显示失败的回测"""
    report = render_portfolio(mock_portfolio_result, show_failed=True)

    assert "FAILED RUNS" in report or "✗" in report


def test_render_portfolio_top_n():
    """测试只显示前N个"""
    report = render_portfolio(mock_portfolio_result, top_n=3)

    # 验证只有3行（需要解析report或检查DataFrame）


def test_format_exit_reason():
    """测试exit_reason格式化"""
    from reports.text_reporter import _format_exit_reason

    assert _format_exit_reason("stop_loss") == "SL"
    assert _format_exit_reason("take_profit") == "TP"
    assert _format_exit_reason("strategy_signal") == "Signal"
```

### 5.2 集成测试（2个）

```python
def test_end_to_end_single_report():
    """测试端到端：回测 → 报表"""
    config = RunConfig(strategy="simple_sma", symbol="BTCUSDT", timeframe="1h")
    result = run_portfolio([config])

    from reports.text_reporter import render_single

    report = render_single(result[0].backtest_result, config=config)

    assert isinstance(report, str)
    assert len(report) > 0


def test_end_to_end_portfolio_report():
    """测试端到端：批量回测 → 排行表"""
    configs = [
        RunConfig(strategy="simple_sma", symbol="BTCUSDT", timeframe="1h"),
        RunConfig(strategy="trend_follow", symbol="BTCUSDT", timeframe="1h")
    ]

    result = run_portfolio(configs)

    from reports.text_reporter import render_portfolio

    report = render_portfolio(result)

    assert "PORTFOLIO" in report
```

---

## 6. CLI测试

### 6.1 E2E测试（5个）

```python
from click.testing import CliRunner
from cli.backtest import run


def test_cli_single_strategy_success():
    """测试单策略CLI成功"""
    runner = CliRunner()
    result = runner.invoke(run, [
        '--strategy', 'simple_sma',
        '--symbol', 'BTCUSDT',
        '--tf', '1h'
    ])

    assert result.exit_code == 0
    assert 'BACKTEST REPORT' in result.output


def test_cli_config_file():
    """测试使用配置文件"""
    runner = CliRunner()
    result = runner.invoke(run, [
        '--config', 'tests/fixtures/test_config.yml'
    ])

    assert result.exit_code == 0 or result.exit_code == 1  # 可能有失败的回测
    assert 'PORTFOLIO' in result.output or 'Error' in result.output


def test_cli_missing_required_params():
    """测试缺少必填参数"""
    runner = CliRunner()
    result = runner.invoke(run, [])

    assert result.exit_code == 2
    assert 'Error' in result.output


def test_cli_invalid_strategy():
    """测试不存在的策略"""
    runner = CliRunner()
    result = runner.invoke(run, [
        '--strategy', 'invalid_strategy',
        '--symbol', 'BTCUSDT',
        '--tf', '1h'
    ])

    assert result.exit_code == 1
    assert 'Strategy not found' in result.output or 'Error' in result.output


def test_cli_output_to_file():
    """测试输出到文件"""
    runner = CliRunner()

    with runner.isolated_filesystem():
        result = runner.invoke(run, [
            '--strategy', 'simple_sma',
            '--symbol', 'BTCUSDT',
            '--tf', '1h',
            '--output', 'report.txt'
        ])

        assert result.exit_code == 0

        # 验证文件存在
        import os
        assert os.path.exists('report.txt')

        # 验证文件内容
        with open('report.txt') as f:
            content = f.read()
            assert 'BACKTEST' in content
```

---

## 7. v0.2兼容性测试

### 7.1 回归测试（2个）

```python
def test_v02_compatibility():
    """测试v0.2的所有测试继续通过"""
    # 运行v0.2的测试套件
    import subprocess

    result = subprocess.run(
        ["python", "tests/test_backtest_v02.py"],
        capture_output=True
    )

    assert result.returncode == 0


def test_default_behavior_is_long_only():
    """测试默认行为仍然是只做多"""
    broker = SimulatedBroker(initial_cash=10000)

    # 默认leverage=1.0
    assert broker.leverage == 1.0

    # 默认direction="flat"
    assert broker.position_direction == "flat"

    # 买入行为不变
    broker.buy(100, 100, pd.Timestamp('2024-01-01'))
    assert broker.position_direction == "long"
```

---

## 8. 测试数据和夹具

### 8.1 测试数据文件

```
tests/
├── fixtures/
│   ├── BTCUSDT_1h_test.csv         # 小数据集（100根K线）
│   ├── BTCUSDT_1h_full.csv         # 完整数据（1000根K线）
│   ├── test_config.yml             # 测试用配置文件
│   ├── test_config_invalid.yml     # 无效配置（用于测试错误处理）
│   └── test_data_with_drop.csv     # 价格下跌数据（测试SL）
```

### 8.2 Mock对象

```python
# tests/conftest.py (pytest fixtures)

import pytest
from backtest.engine import BacktestResult
from execution_engine.portfolio_runner import RunConfig, SingleRunResult


@pytest.fixture
def mock_config():
    """创建测试用RunConfig"""
    return RunConfig(
        strategy="test_strategy",
        symbol="BTCUSDT",
        timeframe="1h"
    )


@pytest.fixture
def mock_backtest_result():
    """创建测试用BacktestResult"""
    equity_curve = pd.Series([10000, 10500, 11000], index=pd.date_range('2024-01-01', periods=3, freq='D'))
    metrics = {
        'total_return': 0.1,
        'max_drawdown': -0.05,
        'num_trades': 5,
        'win_rate': 0.6,
        'profit_factor': 1.5
    }

    return BacktestResult(
        equity_curve=equity_curve,
        trades=[],
        metrics=metrics,
        trade_log=pd.DataFrame()
    )


@pytest.fixture
def mock_success_run(mock_config, mock_backtest_result):
    """创建成功的SingleRunResult"""
    return SingleRunResult(
        strategy="test",
        symbol="BTCUSDT",
        timeframe="1h",
        config=mock_config,
        success=True,
        backtest_result=mock_backtest_result,
        error=None
    )


@pytest.fixture
def mock_failed_run(mock_config):
    """创建失败的SingleRunResult"""
    return SingleRunResult(
        strategy="test",
        symbol="BTCUSDT",
        timeframe="1h",
        config=mock_config,
        success=False,
        backtest_result=None,
        error="Test error"
    )
```

---

## 9. 测试执行策略

### 9.1 测试命令

```bash
# 运行所有测试
pytest tests/

# 运行特定模块测试
pytest tests/test_broker_v03.py
pytest tests/test_engine_v03.py
pytest tests/test_portfolio_runner.py
pytest tests/test_text_reporter.py
pytest tests/test_cli.py

# 生成覆盖率报告
pytest --cov=backtest --cov=execution_engine --cov=reports --cov=cli tests/

# 只运行快速测试（跳过E2E）
pytest -m "not e2e" tests/

# 详细模式
pytest -v tests/
```

### 9.2 持续集成（CI）

```yaml
# .github/workflows/test.yml (示例)

name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: Run tests
        run: pytest --cov=. tests/

      - name: Upload coverage
        uses: codecov/codecov-action@v2
```

---

## 10. 测试覆盖率目标

### 10.1 覆盖率目标

| 模块 | 目标覆盖率 |
|------|-----------|
| backtest/broker.py | 90%+ |
| backtest/engine.py | 85%+ |
| execution_engine/portfolio_runner.py | 85%+ |
| reports/text_reporter.py | 80%+ |
| cli/backtest.py | 75%+ |
| **整体** | **85%+** |

### 10.2 覆盖率检查

```bash
# 生成HTML覆盖率报告
pytest --cov=. --cov-report=html tests/

# 在浏览器中查看
open htmlcov/index.html

# 检查覆盖率是否达标
pytest --cov=. --cov-fail-under=85 tests/
```

---

## 11. 测试文档和可维护性

### 11.1 测试命名规范

```python
# 好的测试名称（描述性强）
def test_open_long_with_leverage()
def test_short_stop_loss_triggered_by_price_rise()
def test_portfolio_result_to_dataframe_excludes_failed_runs()

# 不好的测试名称
def test_broker()
def test_case_1()
def test_it_works()
```

### 11.2 测试文档

每个测试文件应包含docstring:

```python
"""
Tests for Broker v0.3 (Short Selling & Leverage)

Test Coverage:
- Opening long/short positions
- Closing positions with profit/loss
- Leverage position sizing
- Edge cases (zero size, negative equity, etc.)
- Trade object structure
"""
```

---

## 12. 总结

### 12.1 测试清单

- [ ] Broker模块：18个测试
- [ ] Engine模块：10个测试
- [ ] Portfolio Runner：17个测试
- [ ] Text Reporter：10个测试
- [ ] CLI：5个测试
- [ ] v0.2兼容性：2个测试
- [ ] **总计：62个测试**

### 12.2 实施顺序

1. **Phase 1**: Broker单元测试（Day 1）
2. **Phase 2**: Engine单元测试（Day 1-2）
3. **Phase 3**: Portfolio Runner测试（Day 2）
4. **Phase 4**: Text Reporter测试（Day 3）
5. **Phase 5**: CLI E2E测试（Day 3）
6. **Phase 6**: 覆盖率检查和补充（Day 4）

### 12.3 成功标准

- ✅ 所有测试通过
- ✅ 覆盖率 >= 85%
- ✅ v0.2测试继续通过
- ✅ 无代码风格警告（flake8/black）

---

**文档版本**: v1.0
**最后更新**: 2025-12-04
**审核状态**: 待审核
