# Backtest Engine v0.3 - Portfolio Runner API Specification

**版本**: v0.3
**状态**: 设计完成
**日期**: 2025-12-04
**目标**: 定义批量回测执行器的完整API和实现细节

---

## 1. 模块职责（Module Responsibilities）

### 1.1 Portfolio Runner的职责

**负责**:
- 接收多个回测任务配置
- 依次执行每个回测任务
- 捕获并记录错误
- 聚合结果
- 提供结果查询和过滤

**不负责**:
- 策略逻辑（由Strategy负责）
- 回测核心逻辑（由Engine负责）
- 报表生成（由Reporter负责）
- 数据下载（由Data模块负责）

### 1.2 设计原则

1. **简单性**: v0.3使用序列执行，不做并行
2. **健壮性**: 单个回测失败不影响其他回测
3. **可观察性**: 清晰的进度提示和错误记录
4. **可测试性**: 易于mock和单元测试

---

## 2. 完整的类定义

### 2.1 RunConfig（单次回测配置）

```python
# execution_engine/portfolio_runner.py

from dataclasses import dataclass, field
from typing import Optional, Dict, Any
from datetime import datetime


@dataclass
class RunConfig:
    """
    单次回测任务配置

    每个RunConfig对应一次run_backtest()调用
    """
    # 必填字段
    strategy: str          # 策略名称（在registry中查找）
    symbol: str            # 交易对（例如: "BTCUSDT"）
    timeframe: str         # 时间周期（例如: "1h", "4h", "1d"）

    # 可选字段（时间范围）
    start: Optional[str] = None    # 开始日期（YYYY-MM-DD格式）
    end: Optional[str] = None      # 结束日期（YYYY-MM-DD格式）

    # 可选字段（回测参数）
    initial_cash: float = 10000.0
    fee_rate: float = 0.0005
    leverage: float = 1.0

    # 可选字段（Position Sizer）
    position_sizer: Optional[Dict[str, Any]] = None
    # 例如: {"type": "PercentOfEquitySizer", "percent": 0.5}

    # 可选字段（SL/TP）
    stop_loss_pct: Optional[float] = None
    take_profit_pct: Optional[float] = None

    # 可选字段（策略参数）
    strategy_params: Dict[str, Any] = field(default_factory=dict)
    # 例如: {"fast_period": 5, "slow_period": 20}

    def __post_init__(self):
        """验证配置"""
        if not self.strategy:
            raise ValueError("strategy is required")
        if not self.symbol:
            raise ValueError("symbol is required")
        if not self.timeframe:
            raise ValueError("timeframe is required")

        if self.initial_cash <= 0:
            raise ValueError("initial_cash must be positive")
        if self.fee_rate < 0 or self.fee_rate > 0.1:
            raise ValueError("fee_rate must be between 0 and 0.1")
        if self.leverage < 1 or self.leverage > 100:
            raise ValueError("leverage must be between 1 and 100")

    def to_dict(self) -> dict:
        """转换为字典（用于序列化）"""
        return {
            "strategy": self.strategy,
            "symbol": self.symbol,
            "timeframe": self.timeframe,
            "start": self.start,
            "end": self.end,
            "initial_cash": self.initial_cash,
            "fee_rate": self.fee_rate,
            "leverage": self.leverage,
            "position_sizer": self.position_sizer,
            "stop_loss_pct": self.stop_loss_pct,
            "take_profit_pct": self.take_profit_pct,
            "strategy_params": self.strategy_params
        }
```

### 2.2 SingleRunResult（单次回测结果）

```python
@dataclass
class SingleRunResult:
    """
    单次回测任务的执行结果

    无论成功或失败，都会创建一个SingleRunResult对象
    """
    # 配置信息（方便追溯）
    strategy: str
    symbol: str
    timeframe: str
    config: RunConfig

    # 执行结果
    success: bool                                # 是否成功
    backtest_result: Optional['BacktestResult'] = None  # 成功时有值
    error: Optional[str] = None                  # 失败时记录错误

    # 元数据
    execution_time: float = 0.0                  # 执行耗时（秒）
    timestamp: datetime = field(default_factory=datetime.now)

    def get_metrics(self) -> Dict[str, float]:
        """获取metrics（如果成功）"""
        if self.success and self.backtest_result:
            return self.backtest_result.metrics
        else:
            return {}

    def get_metric(self, name: str, default=None):
        """获取单个metric"""
        return self.get_metrics().get(name, default)

    def __repr__(self) -> str:
        if self.success:
            total_return = self.get_metric('total_return', 0)
            return f"<SingleRunResult: {self.strategy}@{self.symbol} [{self.timeframe}] ✓ {total_return:.2%}>"
        else:
            return f"<SingleRunResult: {self.strategy}@{self.symbol} [{self.timeframe}] ✗ {self.error}>"
```

### 2.3 PortfolioResult（批量回测结果）

```python
import pandas as pd
from typing import List, Callable


@dataclass
class PortfolioResult:
    """
    批量回测的聚合结果

    包含多个SingleRunResult，并提供查询、过滤、排序等功能
    """
    runs: List[SingleRunResult]
    total_time: float = 0.0  # 总耗时（秒）

    def __len__(self) -> int:
        """返回回测任务数量"""
        return len(self.runs)

    def __getitem__(self, index: int) -> SingleRunResult:
        """支持索引访问"""
        return self.runs[index]

    def __iter__(self):
        """支持迭代"""
        return iter(self.runs)

    # === 查询方法 ===

    def get_successful_runs(self) -> List[SingleRunResult]:
        """获取所有成功的回测"""
        return [run for run in self.runs if run.success]

    def get_failed_runs(self) -> List[SingleRunResult]:
        """获取所有失败的回测"""
        return [run for run in self.runs if not run.success]

    def get_by_strategy(self, strategy_name: str) -> List[SingleRunResult]:
        """获取特定策略的所有回测"""
        return [run for run in self.runs if run.strategy == strategy_name]

    def get_by_symbol(self, symbol: str) -> List[SingleRunResult]:
        """获取特定交易对的所有回测"""
        return [run for run in self.runs if run.symbol == symbol]

    def filter(self, predicate: Callable[[SingleRunResult], bool]) -> List[SingleRunResult]:
        """自定义过滤"""
        return [run for run in self.runs if predicate(run)]

    # === 排序方法 ===

    def get_best_by(self, metric: str, top_n: int = 1) -> List[SingleRunResult]:
        """
        按某个metric排序，返回最好的N个

        Args:
            metric: 指标名称（例如: "total_return", "profit_factor"）
            top_n: 返回前N个

        Returns:
            排序后的列表（降序）
        """
        successful = self.get_successful_runs()
        if not successful:
            return []

        # 按metric降序排序
        sorted_runs = sorted(
            successful,
            key=lambda r: r.get_metric(metric, float('-inf')),
            reverse=True
        )
        return sorted_runs[:top_n]

    def get_worst_by(self, metric: str, bottom_n: int = 1) -> List[SingleRunResult]:
        """按某个metric排序，返回最差的N个"""
        successful = self.get_successful_runs()
        if not successful:
            return []

        sorted_runs = sorted(
            successful,
            key=lambda r: r.get_metric(metric, float('inf')),
            reverse=False
        )
        return sorted_runs[:bottom_n]

    # === 统计方法 ===

    def count_successful(self) -> int:
        """成功的回测数量"""
        return len(self.get_successful_runs())

    def count_failed(self) -> int:
        """失败的回测数量"""
        return len(self.get_failed_runs())

    def success_rate(self) -> float:
        """成功率"""
        if len(self.runs) == 0:
            return 0.0
        return self.count_successful() / len(self.runs)

    # === DataFrame转换 ===

    def to_dataframe(self, include_failed: bool = False) -> pd.DataFrame:
        """
        转换为DataFrame（排行表）

        Args:
            include_failed: 是否包含失败的回测

        Returns:
            DataFrame with columns:
                - strategy: 策略名称
                - symbol: 交易对
                - timeframe: 时间周期
                - total_return: 总收益率
                - max_drawdown: 最大回撤
                - profit_factor: 盈亏比
                - num_trades: 交易次数
                - win_rate: 胜率
                - execution_time: 执行耗时
                - status: 成功/失败
                - error: 错误信息（仅失败时）
        """
        records = []

        for run in self.runs:
            if not run.success and not include_failed:
                continue

            record = {
                "strategy": run.strategy,
                "symbol": run.symbol,
                "timeframe": run.timeframe,
                "status": "✓" if run.success else "✗",
            }

            if run.success:
                metrics = run.get_metrics()
                record.update({
                    "total_return": metrics.get("total_return", 0),
                    "max_drawdown": metrics.get("max_drawdown", 0),
                    "profit_factor": metrics.get("profit_factor", 0),
                    "num_trades": metrics.get("num_trades", 0),
                    "win_rate": metrics.get("win_rate", 0),
                    "expectancy": metrics.get("expectancy", 0),
                    "execution_time": run.execution_time,
                    "error": ""
                })
            else:
                record.update({
                    "total_return": None,
                    "max_drawdown": None,
                    "profit_factor": None,
                    "num_trades": None,
                    "win_rate": None,
                    "expectancy": None,
                    "execution_time": run.execution_time,
                    "error": run.error or ""
                })

            records.append(record)

        return pd.DataFrame(records)

    # === 辅助方法 ===

    def summary(self) -> str:
        """生成简短摘要"""
        total = len(self.runs)
        success = self.count_successful()
        failed = self.count_failed()

        return (
            f"Portfolio Summary:\n"
            f"  Total runs: {total}\n"
            f"  Successful: {success}\n"
            f"  Failed: {failed}\n"
            f"  Success rate: {self.success_rate():.1%}\n"
            f"  Total time: {self.total_time:.2f}s"
        )

    def __repr__(self) -> str:
        return f"<PortfolioResult: {len(self.runs)} runs, {self.count_successful()} successful>"
```

---

## 3. 核心函数：run_portfolio

### 3.1 函数签名

```python
def run_portfolio(
    configs: List[RunConfig],
    verbose: bool = False,
    fail_fast: bool = False
) -> PortfolioResult:
    """
    批量执行回测任务

    Args:
        configs: 回测配置列表
        verbose: 是否输出详细日志
        fail_fast: 遇到错误时是否立即停止（默认False，继续执行）

    Returns:
        PortfolioResult: 聚合结果

    Raises:
        ValueError: 如果configs为空
    """
```

### 3.2 完整实现

```python
import time
from typing import List
from data.storage import load_ohlcv
from strategies.registry import get_strategy
from backtest.engine import run_backtest
from backtest.position_sizer import (
    AllInSizer, FixedCashSizer, PercentOfEquitySizer
)


def run_portfolio(
    configs: List[RunConfig],
    verbose: bool = False,
    fail_fast: bool = False
) -> PortfolioResult:
    """批量执行回测任务"""

    if not configs:
        raise ValueError("configs cannot be empty")

    results: List[SingleRunResult] = []
    start_time = time.time()

    for i, config in enumerate(configs, 1):
        if verbose:
            print(f"[{i}/{len(configs)}] Running: {config.strategy} on {config.symbol} ({config.timeframe})...")

        # 执行单次回测
        run_result = _run_single_backtest(config, verbose=verbose)
        results.append(run_result)

        # 失败处理
        if not run_result.success:
            if verbose:
                print(f"  ✗ Failed: {run_result.error}")

            if fail_fast:
                # 立即停止
                if verbose:
                    print(f"Stopping due to error (fail_fast=True)")
                break
        else:
            if verbose:
                total_return = run_result.get_metric('total_return', 0)
                print(f"  ✓ Success: {total_return:.2%}")

    total_time = time.time() - start_time

    if verbose:
        print(f"\nCompleted {len(results)} runs in {total_time:.2f}s")
        print(f"  Successful: {sum(1 for r in results if r.success)}")
        print(f"  Failed: {sum(1 for r in results if not r.success)}")

    return PortfolioResult(runs=results, total_time=total_time)


def _run_single_backtest(config: RunConfig, verbose: bool = False) -> SingleRunResult:
    """
    执行单次回测（内部函数）

    捕获所有异常，确保不会中断批量执行
    """
    start_time = time.time()

    try:
        # Step 1: 获取策略类
        try:
            strategy_cls = get_strategy(config.strategy)
        except Exception as e:
            raise ValueError(f"Strategy not found: {config.strategy}") from e

        # Step 2: 加载数据
        data_file = f"data/raw/{config.symbol}_{config.timeframe}.csv"
        try:
            data = load_ohlcv(data_file)
        except FileNotFoundError:
            raise FileNotFoundError(f"Data file not found: {data_file}")
        except Exception as e:
            raise ValueError(f"Failed to load data: {e}") from e

        # Step 3: 过滤时间范围
        if config.start or config.end:
            data = _filter_date_range(data, config.start, config.end)

        if len(data) == 0:
            raise ValueError("No data after date filtering")

        # Step 4: 构建Position Sizer
        position_sizer = _build_position_sizer(config)

        # Step 5: 执行回测
        backtest_result = run_backtest(
            data=data,
            strategy_cls=strategy_cls,
            initial_cash=config.initial_cash,
            fee_rate=config.fee_rate,
            position_sizer=position_sizer,
            stop_loss_pct=config.stop_loss_pct,
            take_profit_pct=config.take_profit_pct
        )

        execution_time = time.time() - start_time

        # 返回成功结果
        return SingleRunResult(
            strategy=config.strategy,
            symbol=config.symbol,
            timeframe=config.timeframe,
            config=config,
            success=True,
            backtest_result=backtest_result,
            error=None,
            execution_time=execution_time
        )

    except Exception as e:
        # 捕获所有错误
        execution_time = time.time() - start_time

        if verbose:
            import traceback
            traceback.print_exc()

        return SingleRunResult(
            strategy=config.strategy,
            symbol=config.symbol,
            timeframe=config.timeframe,
            config=config,
            success=False,
            backtest_result=None,
            error=str(e),
            execution_time=execution_time
        )


def _filter_date_range(
    data: pd.DataFrame,
    start: Optional[str],
    end: Optional[str]
) -> pd.DataFrame:
    """过滤日期范围"""
    if start:
        data = data[data.index >= pd.Timestamp(start)]
    if end:
        data = data[data.index <= pd.Timestamp(end)]
    return data


def _build_position_sizer(config: RunConfig):
    """根据配置构建Position Sizer"""
    if config.position_sizer is None:
        # 默认使用AllInSizer
        return AllInSizer(fee_rate=config.fee_rate)

    ps_type = config.position_sizer.get("type")

    if ps_type == "AllInSizer":
        return AllInSizer(fee_rate=config.fee_rate)

    elif ps_type == "FixedCashSizer":
        cash_amount = config.position_sizer.get("cash_amount", 1000)
        return FixedCashSizer(cash_amount=cash_amount, fee_rate=config.fee_rate)

    elif ps_type == "PercentOfEquitySizer":
        percent = config.position_sizer.get("percent", 0.5)
        return PercentOfEquitySizer(percent=percent, fee_rate=config.fee_rate)

    else:
        raise ValueError(f"Unknown position sizer type: {ps_type}")
```

---

## 4. 错误处理策略

### 4.1 错误分类

| 错误类型 | 处理方式 | fail_fast=True | fail_fast=False |
|----------|----------|----------------|-----------------|
| 配置验证错误 | RunConfig.__post_init__抛出 | 立即终止 | 立即终止 |
| 策略未找到 | 记录到SingleRunResult.error | 立即终止 | 继续下一个 |
| 数据文件不存在 | 记录到SingleRunResult.error | 立即终止 | 继续下一个 |
| 回测执行错误 | 记录到SingleRunResult.error | 立即终止 | 继续下一个 |
| 其他未知错误 | 记录到SingleRunResult.error | 立即终止 | 继续下一个 |

### 4.2 错误信息示例

```python
# 策略未找到
"Strategy not found: unknown_strategy"

# 数据文件不存在
"Data file not found: data/raw/ETHUSDT_1h.csv"

# 数据加载失败
"Failed to load data: Missing column 'close'"

# 日期过滤后无数据
"No data after date filtering"

# Position Sizer配置错误
"Unknown position sizer type: invalid_type"
```

### 4.3 用户反馈

**verbose=True的输出**:
```
[1/5] Running: simple_sma on BTCUSDT (1h)...
  ✓ Success: +18.92%

[2/5] Running: trend_follow on BTCUSDT (1h)...
  ✓ Success: +32.15%

[3/5] Running: breakout on ETHUSDT (1h)...
  ✗ Failed: Data file not found: data/raw/ETHUSDT_1h.csv

[4/5] Running: mean_reversion on BTCUSDT (4h)...
  ✓ Success: +12.43%

[5/5] Running: rsi_strategy on BTCUSDT (1h)...
  ✗ Failed: Strategy not found: rsi_strategy

Completed 5 runs in 12.34s
  Successful: 3
  Failed: 2
```

---

## 5. 使用示例

### 5.1 基本用法：单个配置

```python
from execution_engine.portfolio_runner import RunConfig, run_portfolio

# 创建单个配置
config = RunConfig(
    strategy="simple_sma",
    symbol="BTCUSDT",
    timeframe="1h",
    initial_cash=10000,
    stop_loss_pct=0.02,
    take_profit_pct=0.05
)

# 执行
result = run_portfolio([config], verbose=True)

# 查看结果
print(result[0].get_metrics())
```

### 5.2 批量配置：多策略对比

```python
# 创建多个配置
configs = [
    RunConfig(strategy="simple_sma", symbol="BTCUSDT", timeframe="1h"),
    RunConfig(strategy="trend_follow", symbol="BTCUSDT", timeframe="1h"),
    RunConfig(strategy="mean_reversion", symbol="BTCUSDT", timeframe="1h"),
]

result = run_portfolio(configs, verbose=True)

# 查看排行榜
df = result.to_dataframe()
print(df.sort_values("total_return", ascending=False))
```

### 5.3 批量配置：多商品扫描

```python
symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT"]
configs = [
    RunConfig(strategy="simple_sma", symbol=sym, timeframe="1h")
    for sym in symbols
]

result = run_portfolio(configs, verbose=True)

# 找出最佳商品
best = result.get_best_by("total_return", top_n=1)[0]
print(f"Best symbol: {best.symbol} ({best.get_metric('total_return'):.2%})")
```

### 5.4 使用Position Sizer

```python
config = RunConfig(
    strategy="simple_sma",
    symbol="BTCUSDT",
    timeframe="1h",
    position_sizer={
        "type": "PercentOfEquitySizer",
        "percent": 0.5  # 每次只用50%资金
    }
)

result = run_portfolio([config])
```

### 5.5 错误处理

```python
# 默认模式: 继续执行
result = run_portfolio(configs, verbose=True, fail_fast=False)

# 查看失败的回测
for run in result.get_failed_runs():
    print(f"{run.strategy}@{run.symbol}: {run.error}")

# 严格模式: 遇到错误立即停止
result = run_portfolio(configs, verbose=True, fail_fast=True)
```

---

## 6. 并行执行 vs 序列执行

### 6.1 v0.3的决策：序列执行

**原因**:
1. 实现简单，易于调试
2. 资源可控，不会占用过多内存
3. 对大多数用例性能已足够

**性能估算**:
- 单次回测（1000根K线）: ~0.5秒
- 10个策略 × 1商品: ~5秒
- 5个策略 × 3商品: ~7.5秒

### 6.2 v0.4的扩展：并行执行

**未来实现（不在v0.3范围）**:
```python
# v0.4的可能API
result = run_portfolio(
    configs,
    parallel=True,     # 启用并行
    max_workers=4      # 最多4个进程
)
```

**实现方式**:
- 使用 `multiprocessing.Pool` 或 `concurrent.futures.ProcessPoolExecutor`
- 每个进程独立加载数据和执行回测
- 结果通过pickle序列化返回

**挑战**:
- 数据加载重复（可用共享内存优化）
- 结果聚合复杂度
- 错误处理更困难

---

## 7. 与Config文件的集成

### 7.1 从YAML加载配置

```python
# execution_engine/portfolio_runner.py

import yaml


def load_configs_from_yaml(yaml_path: str) -> List[RunConfig]:
    """
    从YAML文件加载配置

    Args:
        yaml_path: YAML文件路径

    Returns:
        List[RunConfig]

    Raises:
        FileNotFoundError: 文件不存在
        ValueError: 配置格式错误
    """
    with open(yaml_path, 'r') as f:
        data = yaml.safe_load(f)

    if not isinstance(data, dict):
        raise ValueError("YAML root must be a dict")

    runs = data.get("runs", [])
    if not isinstance(runs, list):
        raise ValueError("'runs' must be a list")

    configs = []
    for i, run_dict in enumerate(runs):
        try:
            config = RunConfig(**run_dict)
            configs.append(config)
        except Exception as e:
            raise ValueError(f"Invalid config at index {i}: {e}") from e

    return configs
```

### 7.2 YAML格式示例

```yaml
# configs/multi_strategy.yml

runs:
  - strategy: simple_sma
    symbol: BTCUSDT
    timeframe: 1h
    initial_cash: 10000
    stop_loss_pct: 0.02
    take_profit_pct: 0.05

  - strategy: trend_follow
    symbol: BTCUSDT
    timeframe: 1h
    initial_cash: 10000
    position_sizer:
      type: PercentOfEquitySizer
      percent: 0.5

  - strategy: simple_sma
    symbol: ETHUSDT
    timeframe: 4h
    start: "2024-01-01"
    end: "2024-03-01"
```

### 7.3 使用方式

```python
from execution_engine.portfolio_runner import load_configs_from_yaml, run_portfolio

# 加载配置
configs = load_configs_from_yaml("configs/multi_strategy.yml")

# 执行
result = run_portfolio(configs, verbose=True)

# 查看结果
print(result.to_dataframe())
```

---

## 8. 测试计划（详见v0.3_test_plan.md）

### 8.1 核心测试

1. `test_run_single_backtest_success()`
2. `test_run_single_backtest_strategy_not_found()`
3. `test_run_single_backtest_data_not_found()`
4. `test_run_multiple_backtests()`
5. `test_run_portfolio_with_failures()`

### 8.2 结果对象测试

6. `test_portfolio_result_to_dataframe()`
7. `test_portfolio_result_get_best_by()`
8. `test_portfolio_result_filter()`
9. `test_single_run_result_get_metrics()`

### 8.3 配置测试

10. `test_run_config_validation()`
11. `test_load_configs_from_yaml()`
12. `test_position_sizer_config()`

---

## 9. 性能考虑

### 9.1 瓶颈分析

| 阶段 | 耗时占比 | 优化方向 |
|------|----------|----------|
| 数据加载 | 30% | v0.4: 缓存相同商品数据 |
| 回测执行 | 60% | v0.4: 并行执行 |
| 结果聚合 | 5% | 已优化 |
| 其他 | 5% | N/A |

### 9.2 内存占用

**估算**:
- 单次回测（1000根K线）: ~5 MB
- 10个策略回测: ~50 MB
- 可接受范围

**优化建议（v0.4）**:
- 回测完成后立即释放数据
- 只保留必要的结果

---

## 10. 扩展性设计

### 10.1 未来扩展点

| 功能 | v0.3 | v0.4计划 |
|------|------|---------|
| 并行执行 | ✗ | ✓ |
| 数据缓存 | ✗ | ✓ |
| 进度回调 | ✗ | ✓ |
| 结果持久化 | ✗ | ✓ |
| 断点续传 | ✗ | 考虑中 |

### 10.2 接口稳定性保证

**v0.3 → v0.4的兼容承诺**:
- `RunConfig` 的字段只增不减
- `run_portfolio()` 的基本参数保持不变
- `PortfolioResult` 的核心方法保持不变

---

## 11. 决策记录

### 11.1 为什么用@dataclass而不是dict？

**决策**: 使用 `@dataclass`

**原因**:
1. 类型安全（IDE提示）
2. 自动验证（`__post_init__`）
3. 可扩展（易于添加方法）
4. 可读性好

### 11.2 为什么SingleRunResult同时存储成功和失败？

**决策**: 统一的结果对象

**原因**:
1. 简化API（不需要处理两种返回类型）
2. 易于聚合（所有结果在同一个列表）
3. 便于报表（可以显示成功和失败）

### 11.3 为什么PortfolioResult提供这么多查询方法？

**决策**: 丰富的查询API

**原因**:
1. 用户体验: 常见需求直接提供方法
2. 可发现性: 用户通过IDE自动补全发现功能
3. 避免重复: 用户不需要自己写过滤逻辑

---

## 12. 总结

### 12.1 核心特点

1. **简单**: 序列执行，易于理解
2. **健壮**: 单个失败不影响整体
3. **灵活**: 支持各种查询和过滤
4. **可测试**: 职责清晰，易于mock

### 12.2 使用场景

**适合**:
- 多策略对比研究
- 多商品扫描
- 参数敏感性分析
- 批量回测报告

**不适合**:
- 超大规模回测（>1000个任务）→ 用v0.4并行
- 实时回测 → 不在回测引擎范围

---

**文档版本**: v1.0
**最后更新**: 2025-12-04
**审核状态**: 待审核
