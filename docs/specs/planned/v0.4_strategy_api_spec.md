# Strategy API v1.0 Technical Specification

**ç‰ˆæœ¬**: v1.0  
**ç‹€æ…‹**: è¨­è¨ˆå®Œæˆï¼Œå¾…å¯¦ä½œ  
**ç›®æ¨™ç‰ˆæœ¬**: SuperDog Backtest v0.4.0  

---

## ğŸ¯ è¨­è¨ˆç›®æ¨™

### æ ¸å¿ƒå•é¡Œ
- æ¯æ¬¡æ–°å¢ç­–ç•¥éƒ½éœ€è¦ä¿®æ”¹æ¡†æ¶ä»£ç¢¼
- åƒæ•¸è™•ç†å¯«æ­»åœ¨CLIä¸­
- æ•¸æ“šéœ€æ±‚ç„¡æ³•å‹•æ…‹è²æ˜
- ç­–ç•¥ä¹‹é–“ç¼ºä¹çµ±ä¸€æ¨™æº–

### è§£æ±ºæ–¹æ¡ˆ
- **æ¨™æº–åŒ–ç­–ç•¥æ¥å£** - çµ±ä¸€çš„ç­–ç•¥APIè¦ç¯„
- **å‹•æ…‹åƒæ•¸ç³»çµ±** - ç­–ç•¥è‡ªæè¿°åƒæ•¸éœ€æ±‚
- **è‡ªå‹•æ•¸æ“šè¼‰å…¥** - åŸºæ–¼ç­–ç•¥è²æ˜è‡ªå‹•è¼‰å…¥æ•¸æ“š
- **CLIè‡ªå‹•é©é…** - åƒæ•¸è‡ªå‹•ç”Ÿæˆå‘½ä»¤é¸é …

---

## ğŸ“‹ API è¦æ ¼å®šç¾©

### **1. æ ¸å¿ƒæ¥å£è¨­è¨ˆ**

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import pandas as pd

class ParameterType(Enum):
    """åƒæ•¸é¡å‹æšèˆ‰"""
    FLOAT = "float"
    INT = "int" 
    STR = "str"
    BOOL = "bool"

@dataclass
class ParameterSpec:
    """åƒæ•¸è¦æ ¼å®šç¾©"""
    param_type: ParameterType
    default_value: Any
    description: str
    min_value: Optional[float] = None
    max_value: Optional[float] = None
    choices: Optional[List[str]] = None
    
    def validate(self, value: Any) -> Any:
        """é©—è­‰ä¸¦è½‰æ›åƒæ•¸å€¼"""
        # å¯¦ä½œåƒæ•¸é©—è­‰é‚è¼¯
        pass

class DataSource(Enum):
    """æ•¸æ“šæºé¡å‹"""
    OHLCV = "ohlcv"           # åŸºç¤Kç·šæ•¸æ“š
    FUNDING = "funding"       # è³‡é‡‘è²»ç‡
    OPEN_INTEREST = "oi"      # æŒå€‰é‡
    BASIS = "basis"           # åŸºå·®æ•¸æ“š
    VOLUME_PROFILE = "vp"     # æˆäº¤é‡åˆ†ä½ˆ

@dataclass 
class DataRequirement:
    """æ•¸æ“šéœ€æ±‚å®šç¾©"""
    source: DataSource
    timeframe: Optional[str] = None  # ç‰¹å®šæ™‚é–“é€±æœŸéœ€æ±‚
    lookback_periods: int = 100      # å›æœ›æœŸæ•¸
    required: bool = True            # æ˜¯å¦å¿…éœ€
```

### **2. ç­–ç•¥åŸºåº•é¡åˆ¥**

```python
class BaseStrategy(ABC):
    """ç­–ç•¥åŸºåº•é¡åˆ¥ v2.0"""
    
    def __init__(self):
        self.name = self.__class__.__name__
        self.version = "1.0"
        self.author = "Unknown"
        self.description = ""
        
    @abstractmethod
    def get_parameters(self) -> Dict[str, ParameterSpec]:
        """
        è¿”å›ç­–ç•¥åƒæ•¸è¦æ ¼
        
        Returns:
            Dict[str, ParameterSpec]: åƒæ•¸åç¨±å°æ‡‰è¦æ ¼
            
        Example:
            {
                'sma_short': ParameterSpec(ParameterType.INT, 10, "çŸ­å‡ç·šé€±æœŸ", 5, 50),
                'sma_long': ParameterSpec(ParameterType.INT, 20, "é•·å‡ç·šé€±æœŸ", 10, 100),
                'stop_loss': ParameterSpec(ParameterType.FLOAT, 0.02, "åœææ¯”ä¾‹", 0.01, 0.1)
            }
        """
        pass
    
    @abstractmethod
    def get_data_requirements(self) -> List[DataRequirement]:
        """
        è²æ˜æ•¸æ“šéœ€æ±‚
        
        Returns:
            List[DataRequirement]: ç­–ç•¥æ‰€éœ€çš„æ•¸æ“šæº
            
        Example:
            [
                DataRequirement(DataSource.OHLCV, lookback_periods=200),
                DataRequirement(DataSource.FUNDING, required=False)
            ]
        """
        pass
    
    @abstractmethod
    def compute_signals(self, data: Dict[str, pd.DataFrame], params: Dict[str, Any]) -> pd.Series:
        """
        è¨ˆç®—äº¤æ˜“ä¿¡è™Ÿ
        
        Args:
            data: ç­–ç•¥æ‰€éœ€çš„æ‰€æœ‰æ•¸æ“šï¼Œkeyç‚ºæ•¸æ“šæºåç¨±
            params: ç­–ç•¥åƒæ•¸å­—å…¸
            
        Returns:
            pd.Series: äº¤æ˜“ä¿¡è™Ÿ (1=è²·å…¥, -1=è³£å‡º, 0=æŒæœ‰)
            
        Example:
            data = {
                'ohlcv': DataFrame with OHLCV data,
                'funding': DataFrame with funding rates
            }
            params = {'sma_short': 10, 'sma_long': 20}
        """
        pass
    
    def get_metadata(self) -> Dict[str, Any]:
        """
        ç²å–ç­–ç•¥å…ƒæ•¸æ“š
        
        Returns:
            ç­–ç•¥æè¿°è³‡è¨Š
        """
        return {
            'name': self.name,
            'version': self.version,
            'author': self.author,
            'description': self.description,
            'parameters': list(self.get_parameters().keys()),
            'data_sources': [req.source.value for req in self.get_data_requirements()]
        }
```

### **3. ç­–ç•¥è¨»å†Šå™¨**

```python
class StrategyRegistry:
    """ç­–ç•¥è¨»å†Šèˆ‡ç™¼ç¾ç³»çµ±"""
    
    def __init__(self, strategies_dir: str = "strategies"):
        self.strategies_dir = Path(strategies_dir)
        self._strategies: Dict[str, type] = {}
        self.discover_strategies()
    
    def discover_strategies(self) -> None:
        """è‡ªå‹•ç™¼ç¾ä¸¦è¨»å†Šç­–ç•¥"""
        for strategy_file in self.strategies_dir.glob("*.py"):
            if strategy_file.name.startswith("_"):
                continue
                
            module_name = strategy_file.stem
            try:
                spec = importlib.util.spec_from_file_location(module_name, strategy_file)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # å°‹æ‰¾ç¹¼æ‰¿BaseStrategyçš„é¡åˆ¥
                for name, obj in inspect.getmembers(module, inspect.isclass):
                    if issubclass(obj, BaseStrategy) and obj != BaseStrategy:
                        self._strategies[name.lower()] = obj
                        
            except Exception as e:
                print(f"Warning: Failed to load strategy from {strategy_file}: {e}")
    
    def get_strategy(self, name: str) -> type:
        """ç²å–ç­–ç•¥é¡åˆ¥"""
        if name not in self._strategies:
            raise ValueError(f"Strategy '{name}' not found. Available: {list(self._strategies.keys())}")
        return self._strategies[name]
    
    def list_strategies(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰å¯ç”¨ç­–ç•¥"""
        return list(self._strategies.keys())
    
    def check_dependencies(self, strategy_name: str) -> Dict[str, bool]:
        """æª¢æŸ¥ç­–ç•¥æ•¸æ“šç›¸ä¾æ€§"""
        strategy_cls = self.get_strategy(strategy_name)
        strategy_instance = strategy_cls()
        requirements = strategy_instance.get_data_requirements()
        
        availability = {}
        for req in requirements:
            # æª¢æŸ¥æ•¸æ“šæºæ˜¯å¦å¯ç”¨
            availability[req.source.value] = self._check_data_source(req.source)
        
        return availability
    
    def _check_data_source(self, source: DataSource) -> bool:
        """æª¢æŸ¥ç‰¹å®šæ•¸æ“šæºæ˜¯å¦å¯ç”¨"""
        # å¯¦ä½œæ•¸æ“šæºå¯ç”¨æ€§æª¢æŸ¥é‚è¼¯
        if source == DataSource.OHLCV:
            return True  # åŸºç¤æ•¸æ“šç¸½æ˜¯å¯ç”¨
        elif source in [DataSource.FUNDING, DataSource.OPEN_INTEREST]:
            return False  # v0.4æš«ä¸æ”¯æ´ï¼Œv0.5å¯¦ä½œ
        return False
```

---

## ğŸ® CLI å‹•æ…‹åƒæ•¸ç³»çµ±

### **åƒæ•¸è‡ªå‹•ç”Ÿæˆ**

```python
class DynamicCLI:
    """å‹•æ…‹CLIåƒæ•¸ç”Ÿæˆå™¨"""
    
    def __init__(self, registry: StrategyRegistry):
        self.registry = registry
    
    def generate_strategy_options(self, strategy_name: str) -> Dict[str, click.Option]:
        """ç‚ºæŒ‡å®šç­–ç•¥ç”ŸæˆCLIé¸é …"""
        strategy_cls = self.registry.get_strategy(strategy_name)
        strategy_instance = strategy_cls()
        parameters = strategy_instance.get_parameters()
        
        options = {}
        for param_name, param_spec in parameters.items():
            option_name = f"--{param_name.replace('_', '-')}"
            
            if param_spec.param_type == ParameterType.BOOL:
                options[param_name] = click.option(
                    option_name, 
                    is_flag=True,
                    default=param_spec.default_value,
                    help=param_spec.description
                )
            else:
                python_type = {
                    ParameterType.INT: int,
                    ParameterType.FLOAT: float,
                    ParameterType.STR: str
                }[param_spec.param_type]
                
                options[param_name] = click.option(
                    option_name,
                    type=python_type,
                    default=param_spec.default_value,
                    help=f"{param_spec.description} [default: {param_spec.default_value}]"
                )
        
        return options

def create_dynamic_run_command():
    """å‰µå»ºå‹•æ…‹runå‘½ä»¤"""
    @click.command()
    @click.option('-s', '--strategy', required=True, help='ç­–ç•¥åç¨±')
    @click.option('-m', '--symbol', required=True, help='äº¤æ˜“å°')
    @click.option('-t', '--timeframe', required=True, help='æ™‚é–“é€±æœŸ')
    @click.option('--cash', default=10000.0, help='åˆå§‹è³‡é‡‘')
    @click.option('--fee', default=0.0005, help='æ‰‹çºŒè²»ç‡')
    @click.pass_context
    def dynamic_run(ctx, strategy, symbol, timeframe, cash, fee, **kwargs):
        """å‹•æ…‹ç­–ç•¥åŸ·è¡Œ"""
        registry = StrategyRegistry()
        
        # ç²å–ç­–ç•¥ä¸¦é©—è­‰åƒæ•¸
        strategy_cls = registry.get_strategy(strategy)
        strategy_instance = strategy_cls()
        
        # é©—è­‰ä¸¦è™•ç†ç­–ç•¥ç‰¹å®šåƒæ•¸
        validated_params = {}
        parameters = strategy_instance.get_parameters()
        
        for param_name, param_spec in parameters.items():
            if param_name in kwargs:
                validated_params[param_name] = param_spec.validate(kwargs[param_name])
            else:
                validated_params[param_name] = param_spec.default_value
        
        # åŸ·è¡Œå›æ¸¬
        result = run_backtest_with_strategy(
            strategy_instance=strategy_instance,
            symbol=symbol,
            timeframe=timeframe,
            initial_cash=cash,
            fee_rate=fee,
            strategy_params=validated_params
        )
        
        # è¼¸å‡ºçµæœ
        print_backtest_result(result)
    
    return dynamic_run
```

---

## ğŸ“Š æ•¸æ“šç®¡é“ç³»çµ±

### **å¤šæ•¸æ“šæºè¼‰å…¥**

```python
class DataPipeline:
    """çµ±ä¸€æ•¸æ“šç®¡é“"""
    
    def __init__(self, config: DataConfig):
        self.config = config
        self._cache = {}
    
    def load_strategy_data(
        self, 
        strategy: BaseStrategy, 
        symbol: str, 
        timeframe: str,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None
    ) -> Dict[str, pd.DataFrame]:
        """
        æ ¹æ“šç­–ç•¥éœ€æ±‚è¼‰å…¥æ•¸æ“š
        
        Args:
            strategy: ç­–ç•¥å¯¦ä¾‹
            symbol: äº¤æ˜“å°
            timeframe: æ™‚é–“é€±æœŸ
            start_date: é–‹å§‹æ—¥æœŸ
            end_date: çµæŸæ—¥æœŸ
            
        Returns:
            Dict[str, pd.DataFrame]: æ•¸æ“šæºåç¨±å°æ‡‰æ•¸æ“š
        """
        requirements = strategy.get_data_requirements()
        loaded_data = {}
        
        for req in requirements:
            try:
                if req.source == DataSource.OHLCV:
                    data = self._load_ohlcv(symbol, timeframe, start_date, end_date)
                    if len(data) < req.lookback_periods:
                        if req.required:
                            raise ValueError(f"Insufficient data for {req.source.value}")
                        else:
                            continue
                    loaded_data[req.source.value] = data
                    
                elif req.source == DataSource.FUNDING:
                    # v0.4æš«ä¸å¯¦ä½œï¼Œv0.5æ”¯æ´
                    if req.required:
                        raise ValueError(f"Data source {req.source.value} not yet supported")
                    
            except Exception as e:
                if req.required:
                    raise
                else:
                    print(f"Warning: Failed to load optional data {req.source.value}: {e}")
        
        return loaded_data
    
    def _load_ohlcv(self, symbol: str, timeframe: str, start_date: str, end_date: str) -> pd.DataFrame:
        """è¼‰å…¥OHLCVæ•¸æ“š"""
        cache_key = f"{symbol}_{timeframe}_{start_date}_{end_date}"
        
        if cache_key in self._cache:
            return self._cache[cache_key].copy()
        
        # å¾SSDè¼‰å…¥æ•¸æ“š
        from data.storage import load_ohlcv
        data = load_ohlcv(symbol, timeframe)
        
        if start_date:
            data = data[data.index >= start_date]
        if end_date:
            data = data[data.index <= end_date]
        
        self._cache[cache_key] = data
        return data.copy()
```

---

## ğŸ”§ å¯¦ä½œç¤ºç¯„

### **v0.3 ç­–ç•¥é·ç§»ç¯„ä¾‹**

```python
# åŸæœ‰ SimpleSMA ç­–ç•¥ (v0.3)
class SimpleSMA_Old:
    def __init__(self, short_window=10, long_window=20):
        self.short_window = short_window
        self.long_window = long_window

# æ–°ç‰ˆ SimpleSMA ç­–ç•¥ (v0.4)
class SimpleSMA(BaseStrategy):
    def __init__(self):
        super().__init__()
        self.description = "ç°¡å–®å‡ç·šäº¤å‰ç­–ç•¥"
        self.author = "SuperDog Team"
        
    def get_parameters(self) -> Dict[str, ParameterSpec]:
        return {
            'short_window': ParameterSpec(
                ParameterType.INT, 
                default_value=10,
                description="çŸ­æœŸå‡ç·šé€±æœŸ",
                min_value=1,
                max_value=50
            ),
            'long_window': ParameterSpec(
                ParameterType.INT,
                default_value=20, 
                description="é•·æœŸå‡ç·šé€±æœŸ",
                min_value=5,
                max_value=200
            )
        }
    
    def get_data_requirements(self) -> List[DataRequirement]:
        return [
            DataRequirement(
                DataSource.OHLCV,
                lookback_periods=200
            )
        ]
    
    def compute_signals(self, data: Dict[str, pd.DataFrame], params: Dict[str, Any]) -> pd.Series:
        ohlcv = data['ohlcv']
        close_prices = ohlcv['close']
        
        short_ma = close_prices.rolling(params['short_window']).mean()
        long_ma = close_prices.rolling(params['long_window']).mean()
        
        signals = pd.Series(0, index=close_prices.index)
        signals[short_ma > long_ma] = 1
        signals[short_ma < long_ma] = -1
        
        return signals
```

### **å·æ²ç­–ç•¥ç¤ºç¯„**

```python
class KawamokuStrategy(BaseStrategy):
    def __init__(self):
        super().__init__()
        self.description = "å·æ²å¤šå› å­é‡åŒ–ç­–ç•¥"
        self.author = "DDragon"
        
    def get_parameters(self) -> Dict[str, ParameterSpec]:
        return {
            'funding_weight': ParameterSpec(
                ParameterType.FLOAT,
                default_value=0.5,
                description="è³‡é‡‘è²»ç‡æ¬Šé‡",
                min_value=0.0,
                max_value=1.0
            ),
            'oi_threshold': ParameterSpec(
                ParameterType.FLOAT,
                default_value=1.0,
                description="æŒå€‰é‡è®ŠåŒ–é–¾å€¼",
                min_value=0.1,
                max_value=5.0
            ),
            'basis_lookback': ParameterSpec(
                ParameterType.INT,
                default_value=7,
                description="åŸºå·®è¨ˆç®—å›æœ›æœŸ",
                min_value=1,
                max_value=30
            ),
            'enable_volume_filter': ParameterSpec(
                ParameterType.BOOL,
                default_value=True,
                description="å•Ÿç”¨æˆäº¤é‡éæ¿¾"
            )
        }
    
    def get_data_requirements(self) -> List[DataRequirement]:
        return [
            DataRequirement(DataSource.OHLCV, lookback_periods=100),
            DataRequirement(DataSource.FUNDING, required=False),  # v0.5æ”¯æ´
            DataRequirement(DataSource.OPEN_INTEREST, required=False)  # v0.5æ”¯æ´
        ]
    
    def compute_signals(self, data: Dict[str, pd.DataFrame], params: Dict[str, Any]) -> pd.Series:
        ohlcv = data['ohlcv']
        
        # åŸºæ–¼å¯ç”¨æ•¸æ“šè¨ˆç®—ä¿¡è™Ÿ
        # v0.4 æš«æ™‚åªç”¨OHLCVæ•¸æ“šï¼Œv0.5å°‡æ•´åˆæ›´å¤šå› å­
        
        close_prices = ohlcv['close']
        volume = ohlcv['volume']
        
        # ç°¡åŒ–ç‰ˆå·æ²é‚è¼¯ï¼ˆåŸºæ–¼OHLCVï¼‰
        price_momentum = close_prices.pct_change(5)
        volume_sma = volume.rolling(20).mean()
        volume_ratio = volume / volume_sma
        
        signals = pd.Series(0, index=close_prices.index)
        
        # è²·å…¥æ¢ä»¶ï¼šåƒ¹æ ¼å‹•é‡ + æˆäº¤é‡æ¢ä»¶
        buy_condition = (price_momentum > 0.02) & (volume_ratio > 1.5)
        signals[buy_condition] = 1
        
        # è³£å‡ºæ¢ä»¶
        sell_condition = (price_momentum < -0.02) & (volume_ratio > 1.2)
        signals[sell_condition] = -1
        
        return signals
```

---

## âœ… å¯¦ä½œæª¢æŸ¥æ¸…å–®

### **API å¯¦ä½œ**
- [ ] `strategies/base_v2.py` - æ–°ç‰ˆBaseStrategy
- [ ] `strategies/parameter_spec.py` - åƒæ•¸è¦æ ¼ç³»çµ±
- [ ] `strategies/data_requirements.py` - æ•¸æ“šéœ€æ±‚å®šç¾©
- [ ] `strategies/registry_v2.py` - ç­–ç•¥è¨»å†Šå™¨

### **CLI å‡ç´š**
- [ ] `cli/dynamic_params.py` - å‹•æ…‹åƒæ•¸è™•ç†
- [ ] `cli/main_v2.py` - æ–°ç‰ˆä¸»ç¨‹å¼
- [ ] å‘å¾Œå…¼å®¹v0.3 CLIå‘½ä»¤

### **æ•¸æ“šç³»çµ±**
- [ ] `data/pipeline.py` - æ•¸æ“šç®¡é“ç³»çµ±
- [ ] å¤šæ™‚é–“é€±æœŸæ”¯æ´ (1m, 5m, 15m, 1h, 4h, 1d)
- [ ] å¤šå¹£ç¨®æ”¯æ´æ“´å±•

### **æ¸¬è©¦é©—è­‰**
- [ ] æ‰€æœ‰v0.3ç­–ç•¥èƒ½åœ¨v0.4é‹è¡Œ
- [ ] æ–°APIå®Œæ•´å–®å…ƒæ¸¬è©¦
- [ ] CLIå‹•æ…‹åƒæ•¸æ¸¬è©¦
- [ ] ç«¯åˆ°ç«¯æ•´åˆæ¸¬è©¦

### **æ–‡æª”æ›´æ–°**
- [ ] README.mdæ›´æ–°APIç¯„ä¾‹
- [ ] CHANGELOG.mdè¨˜éŒ„v0.4è®Šæ›´
- [ ] æ–°å¢Strategy APIé–‹ç™¼æŒ‡å—

---

*æœ€å¾Œæ›´æ–°: 2025-12-07*  
*è¦æ ¼ç‰ˆæœ¬: v1.0*
