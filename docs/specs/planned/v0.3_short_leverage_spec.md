# Backtest Engine v0.3 - Short Selling & Leverage Specification

**版本**: v0.3
**状态**: 设计完成
**日期**: 2025-12-04
**目标**: 定义做空和槓桿的完整实现细节（简化模型）

---

## 1. 设计目标（Design Goals）

### 1.1 功能目标

1. 支持做多（long）和做空（short）
2. 支持槓桿倍数设置
3. SL/TP自动感知持仓方向
4. 保持v0.2的所有测试通过

### 1.2 简化假设（Simplifications）

v0.3采用简化模型，以下功能**不实现**:

| 功能 | 是否实现 | 原因 | 未来版本 |
|------|----------|------|----------|
| 保证金计算 | ✗ | 增加复杂度 | v0.5+ |
| 爆仓检测 | ✗ | 简化模型 | v0.5+ |
| 资金费率 | ✗ | 不影响核心回测 | v0.5+ |
| 滑价模拟 | ✗ | 已在v0.2决策 | v0.4+ |
| 未实现盈亏实时计入equity | ✗ | 简化计算 | v0.4+ |
| 分批进出场 | ✗ | Broker限制 | v0.4+ |

**v0.3的做空/槓桿定位**: 让策略能够测试做空信号和槓桿策略，但不追求完全真实的资金模型。

---

## 2. Broker API 完整定义

### 2.1 修改后的SimulatedBroker类

```python
# backtest/broker.py (v0.3)

from dataclasses import dataclass
from typing import List, Optional, Literal
import pandas as pd

DirectionType = Literal["long", "short", "flat"]

@dataclass
class Trade:
    """交易记录（v0.3扩展）"""
    entry_time: pd.Timestamp
    exit_time: pd.Timestamp
    entry_price: float
    exit_price: float
    qty: float                # 数量（绝对值）
    direction: DirectionType  # NEW: "long" | "short"
    pnl: float
    return_pct: float
    leverage: float = 1.0     # NEW: 槓桿倍数


class SimulatedBroker:
    """模拟交易所（v0.3 - 支持做空和槓桿）"""

    def __init__(
        self,
        initial_cash: float,
        fee_rate: float = 0.0005,
        leverage: float = 1.0    # NEW: 默认1倍（无槓桿）
    ):
        """
        初始化模拟交易所

        Args:
            initial_cash: 初始资金
            fee_rate: 手续费率（默认0.05%）
            leverage: 槓桿倍数（默认1倍，范围1-100）
        """
        if leverage < 1 or leverage > 100:
            raise ValueError("Leverage must be between 1 and 100")

        self.initial_cash = initial_cash
        self.cash = initial_cash
        self.fee_rate = fee_rate
        self.leverage = leverage

        # 持仓信息（v0.3改进）
        self.position_qty = 0.0           # 持仓数量（绝对值）
        self.position_direction: DirectionType = "flat"  # NEW: 持仓方向
        self.position_entry_price = 0.0
        self.position_entry_time: Optional[pd.Timestamp] = None

        # 历史记录
        self.equity_history: List[tuple] = []
        self.trades: List[Trade] = []

    @property
    def has_position(self) -> bool:
        """是否有持仓"""
        return self.position_qty > 0 and self.position_direction != "flat"

    @property
    def is_long(self) -> bool:
        """是否持有多单"""
        return self.has_position and self.position_direction == "long"

    @property
    def is_short(self) -> bool:
        """是否持有空单"""
        return self.has_position and self.position_direction == "short"

    def buy(
        self,
        size: float,
        price: float,
        time: pd.Timestamp,
        leverage: Optional[float] = None
    ) -> bool:
        """
        买入（开多或平空）

        语义:
        - 无持仓: 开多单
        - 持有空单: 平空单（全部或部分）
        - 持有多单: 返回False（不支持加仓）

        Args:
            size: 买入数量（必须 > 0）
            price: 买入价格
            time: 买入时间
            leverage: 本次交易的槓桿倍数（可选，默认使用broker的leverage）

        Returns:
            bool: 是否成功执行
        """
        if size <= 0:
            return False

        # 使用指定槓桿或默认槓桿
        lev = leverage if leverage is not None else self.leverage

        # Case 1: 无持仓 -> 开多单
        if self.position_direction == "flat":
            return self._open_long(size, price, time, lev)

        # Case 2: 持有空单 -> 平空单
        elif self.position_direction == "short":
            return self._close_short(size, price, time)

        # Case 3: 持有多单 -> 不支持加仓
        else:  # self.position_direction == "long"
            return False

    def sell(
        self,
        size: float,
        price: float,
        time: pd.Timestamp,
        leverage: Optional[float] = None
    ) -> bool:
        """
        卖出（开空或平多）

        语义:
        - 无持仓: 开空单
        - 持有多单: 平多单（全部或部分）
        - 持有空单: 返回False（不支持加仓）

        Args:
            size: 卖出数量（必须 > 0）
            price: 卖出价格
            time: 卖出时间
            leverage: 本次交易的槓桿倍数（可选）

        Returns:
            bool: 是否成功执行
        """
        if size <= 0:
            return False

        lev = leverage if leverage is not None else self.leverage

        # Case 1: 无持仓 -> 开空单
        if self.position_direction == "flat":
            return self._open_short(size, price, time, lev)

        # Case 2: 持有多单 -> 平多单
        elif self.position_direction == "long":
            return self._close_long(size, price, time)

        # Case 3: 持有空单 -> 不支持加仓
        else:  # self.position_direction == "short"
            return False

    # === 内部方法（私有） ===

    def _open_long(
        self,
        size: float,
        price: float,
        time: pd.Timestamp,
        leverage: float
    ) -> bool:
        """开多单（内部方法）"""
        # 计算成本（考虑槓桿）
        # 槓桿的简化模型: 占用资金 = 仓位价值 / leverage
        position_value = size * price
        required_cash = position_value / leverage
        fee = position_value * self.fee_rate
        total_required = required_cash + fee

        # 检查资金是否足够
        if total_required > self.cash:
            return False

        # 执行开仓
        self.position_qty = size
        self.position_direction = "long"
        self.position_entry_price = price
        self.position_entry_time = time
        self.cash -= total_required

        return True

    def _open_short(
        self,
        size: float,
        price: float,
        time: pd.Timestamp,
        leverage: float
    ) -> bool:
        """开空单（内部方法）"""
        # 做空的简化模型:
        # - 占用资金 = 仓位价值 / leverage
        # - 收入不立即计入cash（简化处理）
        position_value = size * price
        required_cash = position_value / leverage
        fee = position_value * self.fee_rate
        total_required = required_cash + fee

        if total_required > self.cash:
            return False

        # 执行开仓
        self.position_qty = size
        self.position_direction = "short"
        self.position_entry_price = price
        self.position_entry_time = time
        self.cash -= total_required  # 扣除保证金+手续费

        return True

    def _close_long(self, size: float, price: float, time: pd.Timestamp) -> bool:
        """平多单（内部方法）"""
        if not self.is_long:
            return False

        # 实际平仓数量（不能超过持仓）
        actual_size = min(size, self.position_qty)

        # 计算收益
        revenue = actual_size * price
        fee = revenue * self.fee_rate
        net_revenue = revenue - fee

        # 计算PnL
        entry_cost = actual_size * self.position_entry_price
        # entry_fee已在开仓时扣除，这里只扣exit_fee
        pnl = net_revenue - entry_cost

        # 计算return_pct（基于entry价格）
        return_pct = (price - self.position_entry_price) / self.position_entry_price

        # 记录交易
        trade = Trade(
            entry_time=self.position_entry_time,
            exit_time=time,
            entry_price=self.position_entry_price,
            exit_price=price,
            qty=actual_size,
            direction="long",
            pnl=pnl,
            return_pct=return_pct,
            leverage=self.leverage
        )
        self.trades.append(trade)

        # 更新cash（退还占用资金 + PnL）
        # 开仓时扣除了: position_value / leverage + fee_entry
        # 平仓时收到: revenue - fee_exit
        # 总PnL = (revenue - fee_exit) - entry_cost - fee_entry
        released_margin = entry_cost / self.leverage
        self.cash += released_margin + net_revenue

        # 更新持仓
        self.position_qty -= actual_size
        if self.position_qty <= 1e-10:
            self._clear_position()

        return True

    def _close_short(self, size: float, price: float, time: pd.Timestamp) -> bool:
        """平空单（内部方法）"""
        if not self.is_short:
            return False

        actual_size = min(size, self.position_qty)

        # 做空的PnL计算: (entry - exit) * size
        # 买入成本
        cost = actual_size * price
        fee = cost * self.fee_rate
        total_cost = cost + fee

        # 做空收入（在开仓时的理论收入）
        revenue = actual_size * self.position_entry_price

        # PnL = 卖高买低的差价
        pnl = revenue - cost - fee

        # return_pct（做空的回报率）
        return_pct = (self.position_entry_price - price) / self.position_entry_price

        # 记录交易
        trade = Trade(
            entry_time=self.position_entry_time,
            exit_time=time,
            entry_price=self.position_entry_price,
            exit_price=price,
            qty=actual_size,
            direction="short",
            pnl=pnl,
            return_pct=return_pct,
            leverage=self.leverage
        )
        self.trades.append(trade)

        # 更新cash
        released_margin = revenue / self.leverage
        self.cash += released_margin - total_cost

        # 更新持仓
        self.position_qty -= actual_size
        if self.position_qty <= 1e-10:
            self._clear_position()

        return True

    def _clear_position(self):
        """清空持仓状态"""
        self.position_qty = 0.0
        self.position_direction = "flat"
        self.position_entry_price = 0.0
        self.position_entry_time = None

    def update_equity(self, price: float, time: pd.Timestamp):
        """
        更新权益（v0.3: 不计入未实现盈亏）

        简化假设: equity只在平仓时更新，持仓期间不计入mark-to-market

        Args:
            price: 当前价格
            time: 当前时间
        """
        # v0.3简化: equity = cash（不计入浮动盈亏）
        equity = self.cash
        self.equity_history.append((time, equity))

    def get_current_equity(self, price: float) -> float:
        """
        获取当前权益

        v0.3简化版: 返回cash，不计入未实现盈亏

        Args:
            price: 当前价格

        Returns:
            float: 当前权益
        """
        return self.cash

    def get_equity_curve(self) -> pd.Series:
        """获取权益曲线"""
        if not self.equity_history:
            return pd.Series(dtype=float)

        times, equities = zip(*self.equity_history)
        return pd.Series(equities, index=pd.DatetimeIndex(times), name='equity')

    # === v0.2兼容方法（保留） ===

    def buy_all(self, price: float, time: pd.Timestamp) -> bool:
        """
        全仓买入（v0.2兼容）

        v0.3: 调用buy()，size由当前equity计算
        """
        equity = self.get_current_equity(price)
        size = equity / (price * (1 + self.fee_rate) * self.leverage)
        return self.buy(size, price, time)

    def sell_all(self, price: float, time: pd.Timestamp) -> bool:
        """
        全仓卖出（v0.2兼容）

        v0.3: 如果有多单，全部平仓；否则开全仓空单
        """
        if self.is_long:
            return self.sell(self.position_qty, price, time)
        elif self.position_direction == "flat":
            # 开全仓空单
            equity = self.get_current_equity(price)
            size = equity / (price * (1 + self.fee_rate) * self.leverage)
            return self.sell(size, price, time)
        else:
            return False
```

---

## 3. Engine的SL/TP方向感知

### 3.1 修改_check_sl_tp函数

```python
# backtest/engine.py (v0.3修改)

def _check_sl_tp(
    row: pd.Series,
    entry_price: float,
    direction: DirectionType,  # NEW: 新增参数
    stop_loss_pct: Optional[float],
    take_profit_pct: Optional[float]
) -> tuple:
    """
    检查止损止盈是否触发（v0.3 - 方向感知）

    Args:
        row: 当前K线
        entry_price: 进场价格
        direction: 持仓方向（"long" | "short"）
        stop_loss_pct: 止损百分比
        take_profit_pct: 止盈百分比

    Returns:
        (sl_triggered, tp_triggered, exit_price, exit_reason)
    """
    sl_triggered = False
    tp_triggered = False
    exit_price = row['close']
    exit_reason = "strategy_signal"

    # === 多单的SL/TP ===
    if direction == "long":
        # 止损价: entry * (1 - stop_loss_pct)
        if stop_loss_pct is not None and stop_loss_pct > 0:
            sl_price = entry_price * (1 - stop_loss_pct)
        else:
            sl_price = 0

        # 止盈价: entry * (1 + take_profit_pct)
        if take_profit_pct is not None and take_profit_pct > 0:
            tp_price = entry_price * (1 + take_profit_pct)
        else:
            tp_price = float('inf')

        # 检查触发（SL优先）
        if sl_price > 0 and row['low'] <= sl_price:
            sl_triggered = True
            exit_price = sl_price
            exit_reason = "stop_loss"
        elif tp_price < float('inf') and row['high'] >= tp_price:
            tp_triggered = True
            exit_price = tp_price
            exit_reason = "take_profit"

    # === 空单的SL/TP ===
    elif direction == "short":
        # 止损价: entry * (1 + stop_loss_pct)  # 注意: 空单止损是价格上涨
        if stop_loss_pct is not None and stop_loss_pct > 0:
            sl_price = entry_price * (1 + stop_loss_pct)
        else:
            sl_price = float('inf')

        # 止盈价: entry * (1 - take_profit_pct)  # 注意: 空单止盈是价格下跌
        if take_profit_pct is not None and take_profit_pct > 0:
            tp_price = entry_price * (1 - take_profit_pct)
        else:
            tp_price = 0

        # 检查触发（SL优先）
        if sl_price < float('inf') and row['high'] >= sl_price:
            sl_triggered = True
            exit_price = sl_price
            exit_reason = "stop_loss"
        elif tp_price > 0 and row['low'] <= tp_price:
            tp_triggered = True
            exit_price = tp_price
            exit_reason = "take_profit"

    return sl_triggered, tp_triggered, exit_price, exit_reason
```

### 3.2 run_backtest中的调用

```python
# backtest/engine.py (v0.3修改)

# 在主循环中:
if broker.has_position:
    sl_triggered, tp_triggered, exit_price, exit_reason = _check_sl_tp(
        row=row,
        entry_price=broker.position_entry_price,
        direction=broker.position_direction,  # NEW: 传入方向
        stop_loss_pct=stop_loss_pct,
        take_profit_pct=take_profit_pct
    )
```

---

## 4. 槓桿的资金计算

### 4.1 槓桿的定义

**v0.3的槓桿模型**: 只影响资金占用，不影响PnL计算

```
仓位价值 = size * price
占用资金 = 仓位价值 / leverage
实际PnL = size * (exit_price - entry_price)  # 多单
         = size * (entry_price - exit_price)  # 空单
```

**示例**:
```
initial_cash = 10000 USDT
leverage = 5x
price = 100 USDT

无槓桿（1x）:
  size = 10000 / 100 = 100 单位
  占用资金 = 10000 USDT

5倍槓桿:
  size = 10000 * 5 / 100 = 500 单位
  占用资金 = 10000 USDT（全部占用）
  仓位价值 = 50000 USDT

如果价格涨到110:
  PnL = 500 * (110 - 100) = 5000 USDT
  收益率 = 5000 / 10000 = 50%
```

### 4.2 不实现的功能

| 功能 | 说明 | 原因 |
|------|------|------|
| 保证金率检查 | 不检查维持保证金率 | 简化模型 |
| 爆仓 | 不模拟强平 | 简化模型 |
| 未实现盈亏 | 持仓期间不计入equity | 简化计算 |
| 资金费率 | 不扣除funding fee | 不影响核心逻辑 |

### 4.3 边界条件

| 情况 | 处理方式 |
|------|----------|
| leverage < 1 | 抛出ValueError |
| leverage > 100 | 抛出ValueError |
| 资金不足开仓 | 返回False，不执行 |
| equity变为负数 | 允许（v0.3不检查） |

---

## 5. 边界条件处理

### 5.1 size = 0

```python
# broker.buy() / broker.sell()
if size <= 0:
    return False  # 不执行，不报错
```

**测试案例**:
- `test_buy_with_zero_size()`
- `test_sell_with_zero_size()`

### 5.2 equity < 0（亏损超过本金）

**v0.3处理**: 允许equity变为负数，不强制平仓

**原因**: 简化模型，避免复杂的爆仓逻辑

**测试案例**:
- `test_allow_negative_equity()`

### 5.3 同时触发SL和TP

**规则**: SL优先（与v0.2一致）

**代码逻辑**:
```python
if sl_triggered:
    exit_reason = "stop_loss"
    exit_price = sl_price
elif tp_triggered:
    exit_reason = "take_profit"
    exit_price = tp_price
```

### 5.4 空单的SL/TP价格计算错误

**常见错误**: 使用多单的公式计算空单SL/TP

**正确逻辑**:
```
多单:
  SL = entry * (1 - sl_pct)  # 价格下跌触发
  TP = entry * (1 + tp_pct)  # 价格上涨触发

空单:
  SL = entry * (1 + sl_pct)  # 价格上涨触发（亏损）
  TP = entry * (1 - tp_pct)  # 价格下跌触发（盈利）
```

### 5.5 不支持的操作

| 操作 | 当前状态 | 预期行为 |
|------|----------|----------|
| 多单加仓 | 持有多单 | buy()返回False |
| 空单加仓 | 持有空单 | sell()返回False |
| 多空同时持有 | 不可能 | 架构不支持 |
| 分批平仓 | 可以 | sell()/buy()支持部分平仓 |

---

## 6. 与v0.2的兼容性保证

### 6.1 兼容性测试清单

必须通过的v0.2测试:
- ✓ `test_backtest_v02.py` 全部通过
- ✓ 所有只做多的策略行为不变
- ✓ `buy_all()` / `sell_all()` 继续工作

### 6.2 默认行为

**不指定leverage参数**:
```python
broker = SimulatedBroker(initial_cash=10000)  # leverage=1.0
```
- 行为与v0.2完全一致
- 不使用做空
- 不使用槓桿

### 6.3 Trade对象的向后兼容

**v0.2的Trade**:
```python
@dataclass
class Trade:
    entry_time: pd.Timestamp
    exit_time: pd.Timestamp
    entry_price: float
    exit_price: float
    qty: float
    pnl: float
    return_pct: float
```

**v0.3的Trade（向后兼容）**:
```python
@dataclass
class Trade:
    # v0.2字段（位置不变）
    entry_time: pd.Timestamp
    exit_time: pd.Timestamp
    entry_price: float
    exit_price: float
    qty: float
    pnl: float
    return_pct: float
    # v0.3新增字段（带默认值）
    direction: DirectionType = "long"
    leverage: float = 1.0
```

**兼容性**: v0.2的代码读取Trade对象时，新增字段不影响现有字段访问。

---

## 7. 策略如何使用做空

### 7.1 策略示例：双向策略

```python
# strategies/dual_direction_sma.py

from backtest.engine import BaseStrategy

class DualDirectionSMAStrategy(BaseStrategy):
    """双向SMA策略（可做多做空）"""

    def on_bar(self, i: int, row: pd.Series):
        if i < 20:
            return

        # 计算SMA
        sma_fast = self.data['close'].iloc[i-5:i].mean()
        sma_slow = self.data['close'].iloc[i-20:i].mean()

        price = row['close']
        time = row.name

        # 多头信号: 快线上穿慢线
        if sma_fast > sma_slow and not self.broker.is_long:
            # 如果有空单，先平空
            if self.broker.is_short:
                self.broker.buy(self.broker.position_qty, price, time)
            # 开多单
            self.broker.buy_all(price, time)

        # 空头信号: 快线下穿慢线
        elif sma_fast < sma_slow and not self.broker.is_short:
            # 如果有多单，先平多
            if self.broker.is_long:
                self.broker.sell(self.broker.position_qty, price, time)
            # 开空单
            self.broker.sell_all(price, time)
```

### 7.2 使用槓桿

```python
# 在run_backtest中指定槓桿
result = run_backtest(
    data=data,
    strategy_cls=DualDirectionSMAStrategy,
    initial_cash=10000,
    fee_rate=0.0005,
    leverage=3.0,  # 使用3倍槓桿
    stop_loss_pct=0.05,
    take_profit_pct=0.10
)
```

**注意**: Engine需要小幅修改以接受leverage参数并传递给broker。

---

## 8. 已知限制与假设（Critical Assumptions）

### 8.1 已知限制

| 限制 | 说明 | 影响 |
|------|------|------|
| 不模拟保证金 | 只扣除 position_value / leverage | 可能高估可用资金 |
| 不模拟爆仓 | equity可以为负 | 可能出现不现实的亏损 |
| 不计入浮动盈亏 | equity只在平仓时更新 | equity曲线不够平滑 |
| 不支持对冲 | 不能同时持有多空 | 限制策略类型 |

### 8.2 假设

1. **手续费**: 做多和做空的手续费相同
2. **滑价**: 不模拟（与v0.2一致）
3. **资金费率**: 不扣除（对长期回测影响有限）
4. **最小下单量**: 不检查（与v0.2一致）

### 8.3 这些限制的后果

**可能导致的问题**:
- 回测结果偏乐观（未扣资金费率、未模拟爆仓）
- 高槓桿策略的风险被低估
- equity曲线不够真实（不含浮动盈亏）

**适用场景**:
- ✓ 测试做空信号的有效性
- ✓ 对比多空双向策略
- ✓ 研究槓桿对收益的影响
- ✗ 精确模拟实盘资金管理
- ✗ 高槓桿风控研究

---

## 9. 测试案例（详见v0.3_test_plan.md）

### 9.1 核心测试

1. `test_open_long_position()`
2. `test_open_short_position()`
3. `test_close_long_position()`
4. `test_close_short_position()`
5. `test_long_stop_loss()`
6. `test_short_stop_loss()`
7. `test_long_take_profit()`
8. `test_short_take_profit()`
9. `test_leverage_position_sizing()`
10. `test_direction_in_trade_log()`

### 9.2 边界测试

11. `test_buy_with_zero_size()`
12. `test_insufficient_cash()`
13. `test_negative_equity_allowed()`
14. `test_cannot_add_to_long()`
15. `test_cannot_add_to_short()`

### 9.3 兼容性测试

16. `test_v02_compatibility()`  # 运行v0.2全部测试
17. `test_default_long_only()`  # 默认行为是只做多

---

## 10. 实施检查清单（Implementation Checklist）

### Phase 1: Broker修改
- [ ] 修改 `SimulatedBroker.__init__()` 添加leverage参数
- [ ] 添加 `position_direction` 属性
- [ ] 实现 `_open_long()` / `_open_short()`
- [ ] 实现 `_close_long()` / `_close_short()`
- [ ] 修改 `buy()` / `sell()` 语义
- [ ] 更新 `Trade` dataclass
- [ ] 修改 `update_equity()` 和 `get_current_equity()`

### Phase 2: Engine修改
- [ ] 修改 `_check_sl_tp()` 添加direction参数
- [ ] 实现空单的SL/TP逻辑
- [ ] 在主循环中传递 `broker.position_direction`
- [ ] 可选: 添加leverage参数到 `run_backtest()`

### Phase 3: 测试
- [ ] 编写17个测试案例（见上文）
- [ ] 运行v0.2测试确保兼容性
- [ ] 编写集成测试

### Phase 4: 文档
- [ ] 更新 `DECISIONS.md`
- [ ] 更新 `CHANGELOG.md`
- [ ] 编写示例策略

---

## 11. 决策记录（Design Decisions）

### 11.1 为什么不模拟保证金？

**原因**:
1. 简化实现（v0.3目标）
2. 对大多数策略研究影响有限
3. 完整保证金模型留给v0.5+

### 11.2 为什么equity不含浮动盈亏？

**原因**:
1. 简化计算
2. 与v0.2的设计一致（平仓时才更新equity）
3. 对最终回报率无影响

**未来改进**: v0.4可以添加 `get_mark_to_market_equity()` 方法

### 11.3 为什么buy()/sell()语义改为"开/平"？

**原因**:
1. 符合期货/衍生品市场的习惯
2. 支持双向交易
3. 语义更清晰

**对比v0.2**:
- v0.2: buy=开多, sell=平多
- v0.3: buy=开多/平空, sell=开空/平多

---

## 12. 总结（Summary）

### 12.1 v0.3做空/槓桿的核心特点

1. **简化模型**: 不模拟保证金、爆仓、资金费率
2. **向后兼容**: v0.2测试全部通过
3. **方向感知**: SL/TP自动适应多空
4. **易于使用**: 策略只需调用buy()/sell()

### 12.2 适用场景

**适合**:
- 测试做空信号
- 对比多空策略
- 研究槓桿收益

**不适合**:
- 精确资金管理
- 高槓桿风控
- 实盘级别模拟

### 12.3 实施优先级

1. **高优先级**: Broker改造、SL/TP方向感知
2. **中优先级**: 测试案例、文档
3. **低优先级**: 示例策略、优化

---

**文档版本**: v1.0
**最后更新**: 2025-12-04
**审核状态**: 待审核
